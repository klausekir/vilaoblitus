<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Mapa - Vila Abandonada</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #1a1a2e;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .toolbar {
            width: 300px;
            background: #0f0f1e;
            padding: 20px;
            border-right: 3px solid #f0a500;
            overflow-y: auto;
        }

        .toolbar h1 {
            color: #f0a500;
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        .toolbar h2 {
            color: #f0a500;
            font-size: 1.1em;
            margin: 20px 0 10px 0;
            border-bottom: 2px solid #f0a500;
            padding-bottom: 5px;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #16213e;
        }

        #mapCanvas {
            display: block;
            cursor: grab;
            width: 100%;
            height: 100%;
        }

        #mapCanvas.dragging {
            cursor: grabbing;
        }

        .btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: rgba(240, 165, 0, 0.2);
            border: 2px solid #f0a500;
            border-radius: 5px;
            color: #f0a500;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .btn:hover {
            background: rgba(240, 165, 0, 0.4);
            transform: translateX(5px);
        }

        .btn.danger {
            border-color: #F44336;
            color: #F44336;
            background: rgba(244, 67, 54, 0.2);
        }

        .btn.danger:hover {
            background: rgba(244, 67, 54, 0.4);
        }

        .btn.success {
            border-color: #4CAF50;
            color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }

        .btn.success:hover {
            background: rgba(76, 175, 80, 0.4);
        }

        .mode-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin: 10px 0;
        }

        .mode-btn {
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid #666;
            border-radius: 5px;
            color: #999;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
        }

        .mode-btn.active {
            border-color: #f0a500;
            color: #f0a500;
            background: rgba(240, 165, 0, 0.2);
            font-weight: bold;
        }

        .location-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .location-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-left: 3px solid #f0a500;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .location-item:hover {
            background: rgba(240, 165, 0, 0.2);
            transform: translateX(5px);
        }

        .location-item.selected {
            background: rgba(240, 165, 0, 0.3);
            border-left-width: 5px;
        }

        .info-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 0.85em;
            line-height: 1.5;
        }

        .info-box.warning {
            border-left: 4px solid #ff9800;
            color: #ffb74d;
        }

        .info-box.success {
            border-left: 4px solid #4CAF50;
            color: #81C784;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }

        .stat {
            background: rgba(240, 165, 0, 0.1);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            border: 1px solid #f0a500;
        }

        .stat-value {
            font-size: 1.5em;
            color: #f0a500;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.8em;
            color: #999;
        }

        textarea {
            width: 100%;
            height: 200px;
            background: #000;
            color: #0f0;
            border: 2px solid #f0a500;
            border-radius: 5px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            resize: vertical;
        }

        .help-text {
            font-size: 0.75em;
            color: #666;
            margin-top: 5px;
            line-height: 1.4;
        }

        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #f0a500;
        }

        .controls h3 {
            color: #f0a500;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .control-row {
            display: flex;
            gap: 10px;
            margin: 5px 0;
        }

        .control-btn {
            padding: 5px 10px;
            background: rgba(240, 165, 0, 0.2);
            border: 1px solid #f0a500;
            border-radius: 3px;
            color: #f0a500;
            cursor: pointer;
            font-size: 0.85em;
        }

        .control-btn:hover {
            background: rgba(240, 165, 0, 0.4);
        }

        #coordsDisplay {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #f0a500;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Toolbar -->
        <div class="toolbar">
            <a href="admin-panel.html"
                style="display: inline-block; padding: 8px 15px; background: rgba(240, 165, 0, 0.2); border: 2px solid #f0a500; color: #f0a500; text-decoration: none; border-radius: 6px; margin-bottom: 15px; font-size: 14px; font-weight: 600; transition: all 0.3s;"
                onmouseover="this.style.background='rgba(240,165,0,0.4)'"
                onmouseout="this.style.background='rgba(240,165,0,0.2)'">‚Üê Painel Admin</a>

            <h1>üó∫Ô∏è Editor de Mapa</h1>
            <p style="font-size: 0.85em; color: #999; margin-bottom: 20px;">
                Arraste os locais e conecte as cenas visualmente
            </p>

            <!-- Modo de Edi√ß√£o -->
            <h2>Modo de Edi√ß√£o</h2>
            <div class="mode-selector">
                <div class="mode-btn active" data-mode="move">
                    üñêÔ∏è Mover
                </div>
                <div class="mode-btn" data-mode="connect">
                    üîó Conectar
                </div>
            </div>
            <div class="info-box warning">
                <strong>üñêÔ∏è Modo Mover:</strong> Arraste os locais para reposicionar<br>
                <strong>üîó Modo Conectar:</strong> Clique em 2 locais para conectar/desconectar
            </div>

            <!-- Estat√≠sticas -->
            <h2>Estat√≠sticas</h2>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="statLocations">15</div>
                    <div class="stat-label">Locais</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="statConnections">0</div>
                    <div class="stat-label">Conex√µes</div>
                </div>
            </div>

            <!-- Lista de Locais -->
            <h2>Locais</h2>
            <div class="location-list" id="locationList"></div>

            <!-- A√ß√µes -->
            <h2>A√ß√µes</h2>
            <button class="btn" onclick="centerView()">üìç Centralizar C√¢mera</button>
            <button class="btn" onclick="autoArrange()">üéØ Auto-Organizar</button>
            <button class="btn" onclick="exportCode()">üíæ Exportar C√≥digo JS</button>
            <button class="btn success" onclick="saveLayout()">üíæ Salvar Layout</button>
            <button class="btn" onclick="loadLayout()">üìÇ Carregar Layout</button>
            <button class="btn danger" onclick="clearConnections()">üóëÔ∏è Limpar Conex√µes</button>

            <!-- C√≥digo Exportado -->
            <h2>C√≥digo Exportado</h2>
            <textarea id="exportedCode" placeholder="O c√≥digo JavaScript aparecer√° aqui..."></textarea>
            <p class="help-text">
                Copie este c√≥digo e cole no arquivo js/map.js substituindo as posi√ß√µes dos locais.
            </p>
        </div>

        <!-- Canvas -->
        <div class="canvas-container">
            <canvas id="mapCanvas"></canvas>

            <div class="controls">
                <h3>‚å®Ô∏è Atalhos</h3>
                <div style="font-size: 0.8em; line-height: 1.8;">
                    <strong>M</strong> - Modo Mover<br>
                    <strong>C</strong> - Modo Conectar<br>
                    <strong>Space</strong> - Pan (arrastar c√¢mera)<br>
                    <strong>+/-</strong> - Zoom<br>
                    <strong>R</strong> - Resetar Zoom<br>
                    <strong>Delete</strong> - Remover conex√£o selecionada
                </div>
            </div>

            <div id="coordsDisplay">
                Mouse: (0, 0) | Zoom: 100%
            </div>
        </div>
    </div>

    <!-- Dynamic Version -->
    <script>
        const v = Date.now();
        document.write('<script src="js/phaser/managers/DatabaseLoader.js?v=' + v + '"><\/script>');
    </script>

    <script>
        // Start empty, will be populated from DB
        let locations = {};

        // Editor state
        let editorState = {
            mode: 'move', // 'move' or 'connect'
            selectedLocation: null,
            draggingLocation: null,
            firstConnectionPoint: null,
            camera: { x: 0, y: 0, zoom: 1 },
            isDraggingCamera: false,
            dragStartPos: { x: 0, y: 0 }
        };

        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');

        // Initialize
        window.addEventListener('load', async () => {
            await initEditor();
        });

        async function initEditor() {
            // Setup resize listener
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Load data
            await loadFromDatabase();
        }

        async function loadFromDatabase() {
            try {
                document.getElementById('locationList').innerHTML = '<div style="padding:10px; color:#aaa">Carregando dados do banco...</div>';

                // Load via DatabaseLoader
                const gameMap = await databaseLoader.loadGameData();
                const connections = databaseLoader.connections || [];

                // Try to load saved layout (x, y positions) from localStorage
                const savedLayoutJson = localStorage.getItem('vila_abandonada_map_layout');
                const savedLayout = savedLayoutJson ? JSON.parse(savedLayoutJson) : {};

                // Convert DB data to Editor format
                locations = {};

                const dbIds = Object.keys(gameMap);
                const count = dbIds.length;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = 300;

                dbIds.forEach((id, index) => {
                    const loc = gameMap[id];
                    const saved = savedLayout[id];

                    // Determine position: Saved > Calculated > Random
                    let x, y;
                    if (saved) {
                        x = saved.x;
                        y = saved.y;
                    } else {
                        // Place in circle if no saved pos
                        const angle = (index / count) * Math.PI * 2;
                        x = centerX + Math.cos(angle) * radius;
                        y = centerY + Math.sin(angle) * radius;
                    }

                    // Determine connections (outgoing)
                    // DatabaseLoader has a 'connections' array: {from_location, to_location}
                    const locConnections = databaseLoader.getConnections(id);

                    locations[id] = {
                        name: loc.name,
                        x: x,
                        y: y,
                        connections: locConnections,
                        color: getLocationColor(id), // Helper for color
                        size: 35 + (locConnections.length * 2), // Slightly larger if hub
                        items: loc.items || [], // Items da cena
                        puzzle: loc.puzzle // Puzzle da cena (se existir)
                    };
                });

                render();
                updateLocationList();
                updateStats();

            } catch (e) {
                console.error("Error loading data", e);
                alert("Erro ao carregar dados do banco: " + e.message);
            }
        }

        function getLocationColor(id) {
            if (id.includes('forest')) return '#4CAF50';
            if (id.includes('village')) return '#FF9800';
            if (id.includes('church') || id.includes('cemetery')) return '#9C27B0';
            if (id.includes('house')) return '#795548';
            return '#2196F3'; // Default
        }

        // Resize canvas
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            render();
        }

        // Render
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(editorState.camera.x, editorState.camera.y);
            ctx.scale(editorState.camera.zoom, editorState.camera.zoom);

            // Draw connections
            ctx.strokeStyle = 'rgba(240, 165, 0, 0.5)';
            ctx.lineWidth = 3;
            Object.keys(locations).forEach(fromId => {
                const from = locations[fromId];
                from.connections.forEach(toId => {
                    const to = locations[toId];
                    if (to) {
                        ctx.beginPath();
                        ctx.moveTo(from.x, from.y);
                        ctx.lineTo(to.x, to.y);
                        ctx.stroke();

                        // Arrow
                        const angle = Math.atan2(to.y - from.y, to.x - from.x);
                        // Place arrow 60% of the way using lerp
                        const t = 0.6;
                        const arrowX = from.x + (to.x - from.x) * t;
                        const arrowY = from.y + (to.y - from.y) * t;

                        ctx.save();
                        ctx.translate(arrowX, arrowY);
                        ctx.rotate(angle);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-10, -5);
                        ctx.lineTo(-10, 5);
                        ctx.closePath();
                        ctx.fillStyle = '#f0a500';
                        ctx.fill();
                        ctx.restore();
                    }
                });
            });

            // Draw locations
            Object.keys(locations).forEach(id => {
                const loc = locations[id];
                const isSelected = editorState.selectedLocation === id;

                // Circle
                ctx.fillStyle = loc.color || '#888';
                ctx.beginPath();
                ctx.arc(loc.x, loc.y, loc.size, 0, Math.PI * 2);
                ctx.fill();

                // Border
                ctx.strokeStyle = isSelected ? '#fff' : '#000';
                ctx.lineWidth = isSelected ? 4 : 2;
                ctx.stroke();

                // Label
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.strokeText(loc.name, loc.x, loc.y + loc.size + 20);
                ctx.fillText(loc.name, loc.x, loc.y + loc.size + 20);

                // Indicadores de items (amarelo) e puzzles (verde)
                const indicators = [];

                // Adicionar indicador de puzzle (verde)
                if (loc.puzzle) {
                    indicators.push({ color: '#4CAF50', label: 'P' }); // Verde para puzzle
                }

                // Adicionar indicador de items (amarelo)
                if (loc.items && loc.items.length > 0) {
                    indicators.push({ color: '#FFD700', label: loc.items.length }); // Amarelo para items
                }

                // Desenhar indicadores como c√≠rculos pequenos abaixo da cena
                if (indicators.length > 0) {
                    const indicatorRadius = 8;
                    const spacing = 20;
                    const startX = loc.x - ((indicators.length - 1) * spacing) / 2;
                    const startY = loc.y + loc.size + 40;

                    indicators.forEach((indicator, i) => {
                        const x = startX + (i * spacing);

                        // C√≠rculo colorido
                        ctx.fillStyle = indicator.color;
                        ctx.beginPath();
                        ctx.arc(x, startY, indicatorRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // Borda preta
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();

                        // Label (P para puzzle, n√∫mero para items)
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 10px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(indicator.label, x, startY);
                    });
                }
            });

            // Connection preview
            if (editorState.mode === 'connect' && editorState.firstConnectionPoint) {
                const from = locations[editorState.firstConnectionPoint];
                const mousePos = getMousePos(event);
                if (from) { // Safety check
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(from.x, from.y);
                    ctx.lineTo(mousePos.x, mousePos.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            ctx.restore();

            updateStats();
        }

        // Get mouse position
        function getMousePos(e) {
            if (!e) return { x: 0, y: 0 };
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left - editorState.camera.x) / editorState.camera.zoom,
                y: (e.clientY - rect.top - editorState.camera.y) / editorState.camera.zoom
            };
        }

        // Find location at position
        function findLocationAt(x, y) {
            for (let id in locations) {
                const loc = locations[id];
                const dist = Math.sqrt((x - loc.x) ** 2 + (y - loc.y) ** 2);
                if (dist <= loc.size) {
                    return id;
                }
            }
            return null;
        }

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);
            const locId = findLocationAt(pos.x, pos.y);

            if (e.button === 1 || e.shiftKey || e.button === 2) { // Middle click or Shift+click or right click
                editorState.isDraggingCamera = true;
                editorState.dragStartPos = { x: e.clientX - editorState.camera.x, y: e.clientY - editorState.camera.y };
                canvas.style.cursor = 'grabbing';
                e.preventDefault();
                return;
            }

            if (editorState.mode === 'move' && locId) {
                editorState.draggingLocation = locId;
                editorState.selectedLocation = locId;
                updateLocationList();
            } else if (editorState.mode === 'connect' && locId) {
                if (!editorState.firstConnectionPoint) {
                    editorState.firstConnectionPoint = locId;
                    editorState.selectedLocation = locId;
                } else if (editorState.firstConnectionPoint !== locId) {
                    // Visual only connection toggle
                    toggleConnection(editorState.firstConnectionPoint, locId);
                    editorState.firstConnectionPoint = null;
                    editorState.selectedLocation = null;
                }
                updateLocationList();
            }

            render();
        });

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);

            // Update coords display
            document.getElementById('coordsDisplay').textContent =
                `Mouse: (${Math.round(pos.x)}, ${Math.round(pos.y)}) | Zoom: ${Math.round(editorState.camera.zoom * 100)}%`;

            if (editorState.isDraggingCamera) {
                editorState.camera.x = e.clientX - editorState.dragStartPos.x;
                editorState.camera.y = e.clientY - editorState.dragStartPos.y;
                render();
                return;
            }

            if (editorState.draggingLocation) {
                locations[editorState.draggingLocation].x = pos.x;
                locations[editorState.draggingLocation].y = pos.y;
                render();
            } else if (editorState.mode === 'connect' && editorState.firstConnectionPoint) {
                render();
            }

            // Cursor
            const locId = findLocationAt(pos.x, pos.y);
            canvas.style.cursor = locId ? 'pointer' : 'grab';
        });

        canvas.addEventListener('mouseup', () => {
            editorState.draggingLocation = null;
            editorState.isDraggingCamera = false;
            canvas.style.cursor = 'grab';
        });

        // Prevent context menu
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.1;
            const delta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
            editorState.camera.zoom = Math.max(0.1, Math.min(3, editorState.camera.zoom + delta));
            render();
        });

        // Toggle connection
        function toggleConnection(fromId, toId) {
            const from = locations[fromId];
            const to = locations[toId];

            if (from.connections.includes(toId)) {
                // Remove connection
                from.connections = from.connections.filter(id => id !== toId);
                // Also remove reverse if exists? The DB usually has explicit one-way or two-way. 
                // For editor simplicity we might just toggle this one.
                // But wait, the standard map is often bidirectional.
                alert("Nota: Esta mudan√ßa √© apenas visual no editor. Use o 'Editor de Locais (DB)' para alterar conex√µes reais.");
            } else {
                // Add connection
                from.connections.push(toId);
                // to.connections.push(fromId); // Don't force bidirectionality here
                alert("Nota: Esta mudan√ßa √© apenas visual no editor. Use o 'Editor de Locais (DB)' para alterar conex√µes reais.");
            }
        }

        // Update stats
        function updateStats() {
            let totalConnections = 0;
            if (locations) {
                Object.values(locations).forEach(loc => {
                    totalConnections += (loc.connections ? loc.connections.length : 0);
                });
                document.getElementById('statLocations').textContent = Object.keys(locations).length;
                document.getElementById('statConnections').textContent = totalConnections;
            }
        }

        // Mode switching
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                editorState.mode = btn.dataset.mode;
                editorState.firstConnectionPoint = null;
                render();
            });
        });

        // Update location list
        function updateLocationList() {
            const list = document.getElementById('locationList');
            list.innerHTML = '';

            Object.keys(locations).sort().forEach(id => {
                const loc = locations[id];
                const div = document.createElement('div');
                div.className = 'location-item';
                if (editorState.selectedLocation === id) {
                    div.classList.add('selected');
                }
                div.innerHTML = `
                    <strong>${loc.name}</strong><br>
                    <small style="color: #666;">ID: ${id}</small>
                `;
                div.addEventListener('click', () => {
                    editorState.selectedLocation = id;
                    // Center camera on location
                    editorState.camera.x = canvas.width / 2 - (loc.x * editorState.camera.zoom);
                    editorState.camera.y = canvas.height / 2 - (loc.y * editorState.camera.zoom);

                    updateLocationList();
                    render();
                });
                list.appendChild(div);
            });
        }

        // Center view
        function centerView() {
            editorState.camera = { x: 0, y: 0, zoom: 1 };
            render();
        }

        // Auto arrange (Hierarchical Left-to-Right)
        function autoArrange() {
            const keys = Object.keys(locations);
            if (keys.length === 0) return;

            // 1. Identify Root
            // Priority: 'forest_entrance', 'floresta', or first key that has no incoming connections (optional logic), or just first key.
            // For now, simple priority list.
            let rootId = keys.find(k => k === 'forest_entrance' || k === 'floresta' || k === 'start');
            if (!rootId) rootId = keys[0];

            // 2. BFS for Layers
            const levels = new Map(); // id -> level
            const visited = new Set();
            const queue = [{ id: rootId, level: 0 }];

            // Track incoming connections count to find real roots of subgraphs if needed
            // But simple BFS from main root works for connected components.

            while (queue.length > 0) {
                const { id, level } = queue.shift();

                if (visited.has(id)) continue;
                visited.add(id);
                levels.set(id, level);

                const loc = locations[id];
                if (loc && loc.connections) {
                    // Sorting connections to keep consistent order might be nice?
                    loc.connections.forEach(targetId => {
                        if (!visited.has(targetId)) {
                            queue.push({ id: targetId, level: level + 1 });
                        }
                    });
                }
            }

            // Handle disconnected nodes (islands)
            // Assign them to level 0 or put them aside. 
            // Better: Find unvisited and run bfs again with level 0 offset?
            // Let's just put unvisited at level 0 for now to ensure they are visible.
            keys.forEach(id => {
                if (!visited.has(id)) {
                    levels.set(id, 0);
                    // Optionally we could restart BFS here to layout the island properly
                    // But for simplicity let's dump them at x=0
                }
            });

            // 3. Group by Level
            const levelGroups = [];
            levels.forEach((level, id) => {
                if (!levelGroups[level]) levelGroups[level] = [];
                levelGroups[level].push(id);
            });

            // 4. Assign Coordinates
            const xSpacing = 280;
            const ySpacing = 150;
            const startX = 150;
            const canvasCenterY = canvas.height / 2;

            levelGroups.forEach((group, levelIndex) => {
                if (!group) return; // Empty level?

                // Sort group nodes? Maybe by potential parent's Y?
                // For now, alphabetical or ID based stability
                group.sort();

                const nodesInCol = group.length;
                const columnHeight = nodesInCol * ySpacing;
                const startY = canvasCenterY - (columnHeight / 2) + (ySpacing / 2);

                group.forEach((id, nodeIndex) => {
                    const loc = locations[id];

                    // Animate to new position? Direct assignment for editor.
                    loc.x = startX + (levelIndex * xSpacing);
                    loc.y = startY + (nodeIndex * ySpacing);

                    // Add slight random jitter to prevent perfect overlap if logic fails? No, grid is better.
                });
            });

            render();
            centerViewToStart(startX, canvasCenterY); // Optional: center on start
        }

        function centerViewToStart(x, y) {
            editorState.camera.x = canvas.width / 2 - x;
            editorState.camera.y = canvas.height / 2 - y;
            render();
        }

        // Export code
        function exportCode() {
            let code = '// Posi√ß√µes dos locais (Cole em js/map.js)\n\n';
            code += 'const mapPositions = {\n';

            Object.keys(locations).forEach(id => {
                const loc = locations[id];
                code += `    ${id}: { x: ${Math.round(loc.x)}, y: ${Math.round(loc.y)} },\n`;
            });

            code += '};\n\n';

            document.getElementById('exportedCode').value = code;
            document.getElementById('exportedCode').select();
        }

        // Save layout
        function saveLayout() {
            // We only save the x,y positions to localStorage, not the whole DB struct
            const layoutData = {};
            Object.keys(locations).forEach(id => {
                layoutData[id] = {
                    x: locations[id].x,
                    y: locations[id].y
                };
            });
            const data = JSON.stringify(layoutData, null, 2);
            localStorage.setItem('vila_abandonada_map_layout', data);
            alert('Layout visual salvo no navegador com sucesso!');
        }

        // Load layout (Manual trigger, though auto-loaded on start)
        function loadLayout() {
            loadFromDatabase();
            // Re-calling loadFromDatabase includes loading layout
        }

        // Clear connections (Visual only)
        function clearConnections() {
            if (confirm('Isto apenas limpa a visualiza√ß√£o. Para apagar conex√µes reais, use o Editor de DB.')) {
                Object.values(locations).forEach(loc => {
                    loc.connections = [];
                });
                render();
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'm' || e.key === 'M') {
                document.querySelector('.mode-btn[data-mode="move"]').click();
            } else if (e.key === 'c' || e.key === 'C') {
                document.querySelector('.mode-btn[data-mode="connect"]').click();
            } else if (e.key === 'r' || e.key === 'R') {
                centerView();
            }
        });

        // Initial render logic is in initEditor()
    </script>
</body>

</html>