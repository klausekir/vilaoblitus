<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Locais e Enigmas - Vila Abandonada</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: #333;
        }

        .editor-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Left Sidebar */
        .locations-sidebar {
            width: 300px;
            background: rgba(255, 255, 255, 0.95);
            border-right: 2px solid #ddd;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .sidebar-header h2 {
            font-size: 18px;
            margin-bottom: 10px;
        }

        .add-location-btn {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
        }

        .add-location-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.02);
        }

        .locations-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .location-item {
            padding: 12px;
            margin-bottom: 8px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .location-item:hover {
            border-color: #667eea;
            transform: translateX(5px);
        }

        .location-item.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }

        .location-item.dragging {
            opacity: 0.4;
        }

        .location-item.drag-over {
            border-top: 3px solid #667eea;
        }

        .location-item-name {
            font-weight: 600;
        }

        .location-item-id {
            font-size: 11px;
            opacity: 0.7;
        }

        .delete-location-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .delete-location-btn:hover {
            background: #cc0000;
        }

        /* Main Editor Area */
        .editor-main {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
        }

        .editor-header {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .editor-header h1 {
            color: #667eea;
            margin-bottom: 5px;
        }

        .editor-header .location-id {
            color: #999;
            font-size: 14px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab-btn {
            padding: 12px 24px;
            background: white;
            border: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .tab-btn:hover {
            background: #f0f0f0;
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .tab-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            min-height: 400px;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #555;
        }

        .form-group input[type="text"],
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group textarea {
            min-height: 100px;
            resize: vertical;
            font-family: inherit;
        }

        .form-hint {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
        }

        /* Puzzle Editor */
        .puzzle-type-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .puzzle-type-btn {
            padding: 15px;
            background: #f5f5f5;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .puzzle-type-btn:hover {
            border-color: #667eea;
            background: #f0f0ff;
        }

        .puzzle-type-btn.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        /* Items & Hotspots List */
        .items-list,
        .hotspots-list,
        .connections-list {
            margin-top: 20px;
        }

        .list-item {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border: 2px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .list-item-content {
            flex: 1;
        }

        .list-item-title {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .list-item-details {
            font-size: 12px;
            color: #666;
        }

        .list-item-actions {
            display: flex;
            gap: 8px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: #4caf50;
            color: white;
        }

        .btn-success:hover {
            background: #45a049;
        }

        .btn-danger {
            background: #ff4444;
            color: white;
        }

        .btn-danger:hover {
            background: #cc0000;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Export Section */
        .export-section {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        .export-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
            transition: all 0.3s;
        }

        .export-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.6);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ff4444;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
        }

        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            max-height: 600px;
        }

        .copy-code-btn {
            margin-top: 10px;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #999;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .form-row-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
        }

        .save-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4caf50;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .save-indicator.show {
            opacity: 1;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            font-size: 15px;
            z-index: 10000;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: none;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        .toast.success {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
        }

        .toast.error {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
        }

        .toast.warning {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
        }

        .toast.info {
            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
        }
    </style>
</head>

<body>
    <!-- Admin Authentication Check -->
    <script>
        // Check if user is admin
        const isAdmin = localStorage.getItem('is_admin') === 'true';
        const username = localStorage.getItem('username');

        if (!isAdmin) {
            alert('‚ùå Acesso Negado\n\nApenas administradores podem acessar o Editor.\n\nVoc√™ ser√° redirecionado para o jogo.');
            window.location.href = 'game-phaser.html';
        } else {
        }
    </script>

    <div class="editor-container">
        <!-- Left Sidebar -->
        <div class="locations-sidebar">
            <div class="sidebar-header">
                <a href="admin-panel.html"
                    style="display: inline-block; padding: 8px 15px; background: rgba(255,255,255,0.2); color: white; text-decoration: none; border-radius: 4px; margin-bottom: 15px; font-size: 14px; transition: all 0.3s;"
                    onmouseover="this.style.background='rgba(255,255,255,0.3)'"
                    onmouseout="this.style.background='rgba(255,255,255,0.2)'">‚Üê Painel Admin</a>
                <h2>Locais do Jogo</h2>
                <button class="add-location-btn" onclick="addNewLocation()">+ Adicionar Novo Local</button>
                <button class="btn btn-danger" onclick="resetEditorData()" style="width: 100%; margin-top: 10px;">üîÑ
                    Resetar Dados do Editor</button>
            </div>
            <div class="locations-list" id="locationsList">
                <!-- Populated by JS -->
            </div>
        </div>

        <!-- Main Editor -->
        <div class="editor-main">
            <div class="editor-header">
                <h1 id="currentLocationName">Selecione um local</h1>
                <div class="location-id" id="currentLocationId"></div>
            </div>

            <div class="tabs">
                <button class="tab-btn active" onclick="switchTab('basic')">üìù Informa√ß√µes B√°sicas</button>
                <button class="tab-btn" onclick="switchTab('visual')">üñºÔ∏è Posicionamento Visual</button>
                <button class="tab-btn" onclick="switchTab('puzzle')">üß© Enigma</button>
                <button class="tab-btn" onclick="switchTab('items')">üíé Itens</button>
                <button class="tab-btn" onclick="switchTab('hotspots')">üéØ Hotspots</button>
                <button class="tab-btn" onclick="switchTab('connections')">üîó Conex√µes</button>
                <button class="tab-btn" onclick="switchTab('walls')">üß± Paredes</button>
            </div>

            <div class="tab-content">
                <!-- Basic Info Tab -->
                <div class="tab-panel active" id="tab-basic">
                    <div class="form-group">
                        <label>ID do Local</label>
                        <input type="text" id="edit-id" placeholder="ex: forest_entrance" onchange="saveBasicInfo()">
                        <div class="form-hint">Identificador √∫nico (sem espa√ßos, use underscore)</div>
                    </div>

                    <div class="form-group">
                        <label>Nome do Local</label>
                        <input type="text" id="edit-name" placeholder="ex: Entrada da Floresta"
                            onchange="saveBasicInfo()">
                    </div>

                    <div class="form-group">
                        <label>Descri√ß√£o</label>
                        <textarea id="edit-description" placeholder="Descreva o local..."
                            onchange="saveBasicInfo()"></textarea>
                    </div>

                    <div class="form-group">
                        <label>Imagem do Local</label>
                        <input type="text" id="edit-image" placeholder="ex: images/forest_entrance.jpg"
                            onchange="saveBasicInfo()">
                        <div class="form-hint">Caminho relativo para a imagem</div>

                        <div style="margin-top: 10px;">
                            <input type="file" id="location-image-upload" accept="image/*" style="display: none;"
                                onchange="handleLocationImageUpload(event)">
                            <button class="btn btn-secondary"
                                onclick="document.getElementById('location-image-upload').click()">üìÅ Fazer Upload da
                                Imagem</button>
                        </div>

                        <div id="location-image-preview" style="margin-top: 15px; display: none;">
                            <img id="location-preview-img"
                                style="max-width: 100%; max-height: 300px; border-radius: 8px; border: 2px solid #e0e0e0;">
                        </div>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="edit-unlocked" onchange="saveBasicInfo()">
                        <label for="edit-unlocked">Local desbloqueado no in√≠cio do jogo</label>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="edit-final-scene" onchange="saveBasicInfo(); toggleCreditsSection(); syncToDatabase(true);">
                        <label for="edit-final-scene">üé¨ Cena Final (Mostrar Cr√©ditos Estilo Star Wars)</label>
                    </div>

                    <div id="transition-video-section" style="display: none; margin-top: 15px; padding: 15px; background: #fff3cd; border-radius: 8px; border-left: 4px solid #ffc107;">
                        <h4 style="margin-bottom: 10px; color: #856404;">üé• V√≠deo de Transi√ß√£o</h4>
                        <div class="form-group">
                            <label for="edit-transition-video" style="font-weight: normal; color: #856404;">Caminho do v√≠deo MP4 (relativo √† raiz do projeto)</label>
                            <input type="text" id="edit-transition-video" placeholder="images/Fuga_da_Vila_com_Salva√ß√£o_Policial.mp4" onchange="saveBasicInfo(); syncToDatabase(true);" style="width: 100%; padding: 8px; border: 1px solid #ffc107; border-radius: 4px;">
                            <small style="color: #856404; display: block; margin-top: 5px;">Este v√≠deo ser√° reproduzido antes de entrar na cena final</small>
                        </div>
                    </div>

                    <div id="dramatic-messages-section" style="display: none; margin-top: 15px; padding: 15px; background: #ffe4e1; border-radius: 8px; border-left: 4px solid #dc3545;">
                        <h4 style="margin-bottom: 10px; color: #721c24;">‚ö° Mensagens Dram√°ticas</h4>
                        <div class="form-group">
                            <label for="edit-dramatic-messages" style="font-weight: normal; color: #721c24;">Mensagens (uma por linha)</label>
                            <textarea id="edit-dramatic-messages" rows="5" placeholder="VOC√ä CONSEGUIU SAIR DA VILA&#10;MAS ESPERE A VILA N√ÉO ESTAVA ABANDONADA&#10;OLHE PARA TR√ÅS E VEJA" onchange="saveBasicInfo(); syncToDatabase(true);" style="width: 100%; padding: 8px; border: 1px solid #dc3545; border-radius: 4px; font-family: Arial, sans-serif;"></textarea>
                            <small style="color: #721c24; display: block; margin-top: 5px;">Cada linha ser√° exibida em sequ√™ncia antes do v√≠deo</small>
                        </div>
                        <div class="form-group" style="margin-top: 10px;">
                            <label for="edit-dramatic-duration" style="font-weight: normal; color: #721c24;">Dura√ß√£o por mensagem (segundos)</label>
                            <input type="number" id="edit-dramatic-duration" placeholder="5" min="1" max="30" value="5" onchange="saveBasicInfo(); syncToDatabase(true);" style="width: 150px; padding: 8px; border: 1px solid #dc3545; border-radius: 4px;">
                            <small style="color: #721c24; display: block; margin-top: 5px;">Tempo que cada mensagem ficar√° na tela (padr√£o: 5 segundos)</small>
                        </div>
                    </div>

                    <div id="credits-section" style="display: none; margin-top: 20px; padding: 15px; background: #f0f8ff; border-radius: 8px; border-left: 4px solid #4a90e2;">
                        <h4 style="margin-bottom: 15px; color: #2a5885;">‚ú® Cr√©ditos Finais</h4>
                        <div style="margin-bottom: 10px;">
                            <button class="btn btn-primary" onclick="addCreditLine()" style="width: 100%;">
                                ‚ûï Adicionar Texto
                            </button>
                        </div>
                        <div id="credits-list" style="margin-top: 15px;">
                            <!-- Credits populated by JS -->
                        </div>
                    </div>

                </div>

                <!-- Visual Positioning Tab -->
                <div class="tab-panel" id="tab-visual">
                    <h3>Posicionamento Visual de Itens e Hotspots</h3>
                    <p style="color: #666; margin-bottom: 20px;">Arraste itens PNG e desenhe √°reas clic√°veis sobre a
                        imagem</p>

                    <div style="display: grid; grid-template-columns: 250px 1fr 280px; gap: 20px;">
                        <!-- Left Panel: Items + Hotspots -->
                        <div
                            style="background: #f9f9f9; padding: 15px; border-radius: 8px; max-height: 600px; overflow-y: auto;">
                            <h4 style="margin-bottom: 15px;">Itens Dispon√≠veis</h4>
                            <div id="visual-items-list" style="margin-bottom: 20px;">
                                <!-- Populated by JS -->
                            </div>

                            <hr style="margin: 20px 0; border: none; border-top: 2px solid #ddd;">

                            <h4 style="margin-bottom: 10px;">üéØ Hotspots de Navega√ß√£o</h4>
                            <button class="btn btn-primary" onclick="startDrawingHotspot()"
                                style="width: 100%; margin-bottom: 10px; font-size: 12px;">
                                ‚ûï Desenhar √Årea
                            </button>
                            <div id="visual-hotspots-list">
                                <!-- Populated by JS -->
                            </div>

                            <hr style="margin: 20px 0; border: none; border-top: 2px solid #ddd;">

                            <h4 style="margin-bottom: 10px;">üß± Paredes Destrut√≠veis</h4>
                            <div id="visual-walls-list">
                                <!-- Populated by JS -->
                            </div>
                        </div>

                        <!-- Canvas Area -->
                        <div
                            style="background: #1e1e1e; border-radius: 8px; padding: 20px; position: relative; overflow: visible;">
                            <div id="visual-wrapper"
                                style="position: relative; display: inline-block; max-width: 100%; overflow: visible;">
                                <img id="visual-location-image"
                                    style="max-width: 100%; display: block; border-radius: 8px;" src=""
                                    alt="Imagem do local">
                                <div id="visual-hotspots-container"
                                    style="position: absolute; top: 0; left: 0; pointer-events: auto; overflow: visible;">
                                    <!-- Hotspots drawn here -->
                                </div>
                                <div id="visual-walls-container"
                                    style="position: absolute; top: 0; left: 0; pointer-events: none; overflow: visible; z-index: 40;">
                                    <!-- Walls drawn here -->
                                </div>
                                <div id="visual-items-container"
                                    style="position: absolute; top: 0; left: 0; pointer-events: none; overflow: visible; perspective: 1000px; z-index: 50;">
                                    <!-- Items positioned here -->
                                </div>
                            </div>
                            <div id="visual-no-image" style="color: #999; text-align: center; padding: 100px 20px;">
                                <div style="font-size: 48px; margin-bottom: 20px;">üñºÔ∏è</div>
                                <p>Fa√ßa upload da imagem do local na aba "Informa√ß√µes B√°sicas"</p>
                            </div>
                        </div>

                        <!-- Transform Controls Panel -->
                        <div
                            style="background: #f9f9f9; padding: 15px; border-radius: 8px; max-height: 600px; overflow-y: auto;">
                            <h4 style="margin-bottom: 15px;">Transforma√ß√µes</h4>
                            <div id="transform-controls">
                                <div style="color: #999; text-align: center; padding: 20px; font-size: 14px;">
                                    Selecione um item para editar
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Puzzle Tab -->
                <div class="tab-panel" id="tab-puzzle">
                    <h3>Configurar Enigma</h3>

                    <div class="checkbox-group">
                        <input type="checkbox" id="has-puzzle" onchange="togglePuzzleEditor()">
                        <label for="has-puzzle">Este local tem um enigma</label>
                    </div>

                    <div id="puzzle-editor" style="display: none;">
                        <div class="form-group">
                            <label>ID do Enigma</label>
                            <input type="text" id="puzzle-id" placeholder="ex: fountain_puzzle" onchange="savePuzzle()">
                        </div>

                        <div class="form-group">
                            <label>Tipo de Enigma</label>
                            <div class="puzzle-type-selector">
                                <div class="puzzle-type-btn" onclick="selectPuzzleType('riddle')">
                                    <div>üìú Charada</div>
                                    <small>M√∫ltipla escolha</small>
                                </div>
                                <div class="puzzle-type-btn" onclick="selectPuzzleType('sequence_symbols')">
                                    <div>üî¢ Sequ√™ncia</div>
                                    <small>Ordem correta</small>
                                </div>
                                <div class="puzzle-type-btn" onclick="selectPuzzleType('math')">
                                    <div>‚ûï Matem√°tica</div>
                                    <small>C√°lculo</small>
                                </div>
                                <div class="puzzle-type-btn" onclick="selectPuzzleType('code')">
                                    <div>üîê C√≥digo</div>
                                    <small>Senha num√©rica</small>
                                </div>
                                <div class="puzzle-type-btn" onclick="selectPuzzleType('item_combination')">
                                    <div>üîß Combinar Itens</div>
                                    <small>Items necess√°rios</small>
                                </div>
                                <div class="puzzle-type-btn" onclick="selectPuzzleType('padlock_5digit')">
                                    <div>üîí Cadeado 5 D√≠gitos</div>
                                    <small>Senha num√©rica 5 d√≠gitos</small>
                                </div>
                                <div class="puzzle-type-btn" onclick="selectPuzzleType('egyptian')">
                                    <div>ìÇÄ Parede Eg√≠pcia</div>
                                    <small>Rotacionar pe√ßas</small>
                                </div>
                                <div class="puzzle-type-btn" onclick="selectPuzzleType('shape_match')">
                                    <div>üî∑ Conecta Blocos</div>
                                    <small>Encaixar formas</small>
                                </div>
                            </div>
                        </div>

                        <div id="puzzle-options-container">
                            <!-- Populated dynamically based on puzzle type -->
                        </div>

                        <div class="form-group">
                            <label>Item de Recompensa - ID</label>
                            <input type="text" id="puzzle-reward-id" placeholder="ex: fountain_key"
                                onchange="savePuzzle()">
                        </div>

                        <div class="form-group">
                            <label>Item de Recompensa - Nome</label>
                            <input type="text" id="puzzle-reward-name" placeholder="ex: Chave da Fonte"
                                onchange="savePuzzle()">
                        </div>

                        <div class="form-group">
                            <label>Imagem da Recompensa (opcional)</label>
                            <input type="text" id="puzzle-reward-image" placeholder="images/items/tesouro.png"
                                onchange="savePuzzle()">
                            <div class="form-hint">Use caminho relativo, ex: images/items/tesouro.png</div>
                        </div>


                    </div>
                </div>

                <!-- Items Tab -->
                <div class="tab-panel" id="tab-items">
                    <h3>Itens Colecion√°veis</h3>
                    <button class="btn btn-primary" onclick="addNewItem()" style="margin-bottom: 20px;">+ Adicionar
                        Item</button>

                    <div class="items-list" id="itemsList">
                        <!-- Populated by JS -->
                    </div>
                </div>

                <!-- Hotspots Tab -->
                <div class="tab-panel" id="tab-hotspots">
                    <h3>Hotspots Interativos</h3>
                    <button class="btn btn-primary" onclick="addNewHotspot()" style="margin-bottom: 20px;">+ Adicionar
                        Hotspot</button>

                    <div class="hotspots-list" id="hotspotsList">
                        <!-- Populated by JS -->
                    </div>
                </div>

                <!-- Connections Tab -->
                <div class="tab-panel" id="tab-connections">
                    <h3>Conex√µes com Outros Locais</h3>
                    <p style="margin-bottom: 20px; color: #666;">Selecione os locais que podem ser acessados a partir
                        deste local.</p>

                    <div class="connections-list" id="connectionsList">
                        <!-- Populated by JS -->
                    </div>
                </div>

                <!-- Walls Tab -->
                <div class="tab-panel" id="tab-walls">
                    <h3>Paredes Destrut√≠veis</h3>
                    <p style="margin-bottom: 20px; color: #666;">Configure paredes que podem ser destru√≠das por itens.
                    </p>
                    <button class="btn btn-primary" onclick="addNewDestructibleWall()" style="margin-bottom: 20px;">+
                        Adicionar Parede</button>

                    <div class="items-list" id="wallsList">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Save Button -->
    <div class="export-section">
        <button class="export-btn" onclick="manualSave()" style="background: #28a745; font-size: 18px; font-weight: bold;">üíæ Salvar</button>
        <button class="export-btn" onclick="forceReloadFromDatabase();" style="background: #007bff; margin-left: 10px;">üîÑ Recarregar do Banco</button>
    </div>

    <!-- Save Indicator -->
    <div id="saveIndicator" class="save-indicator">
        <i class="fas fa-check-circle"></i> Salvo no servidor
    </div>

    <!-- Export Modal -->
    <div class="modal" id="exportModal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeExportModal()">√ó</button>
            <h2>C√≥digo Exportado - map.js</h2>
            <p>Copie o c√≥digo abaixo e substitua o conte√∫do do arquivo <strong>js/map.js</strong></p>
            <div class="code-block" id="exportedCode"></div>
            <button class="btn btn-primary copy-code-btn" onclick="copyExportedCode()">üìã Copiar C√≥digo</button>
        </div>
    </div>

    <!-- Hotspot Navigation Modal -->
    <div class="modal" id="hotspotNavModal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <h2 id="hotspotNavModalTitle">Adicionar Hotspot de Navega√ß√£o</h2>
            <div class="form-group">
                <label>Nome do Hotspot:</label>
                <input type="text" id="hotspotNavName" placeholder="Ex: Porta da Entrada" style="width: 100%; padding: 8px; margin-top: 5px;">
            </div>
            <div class="form-group" style="margin-top: 15px;">
                <label>Local de Destino:</label>
                <select id="hotspotNavTarget" style="width: 100%; padding: 8px; margin-top: 5px;">
                    <option value="">-- Selecione uma localiza√ß√£o --</option>
                </select>
            </div>
            <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="cancelHotspotNav()" style="padding: 10px 20px; background: #ccc; border: none; border-radius: 4px; cursor: pointer;">Cancelar</button>
                <button onclick="confirmHotspotNav()" style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">Confirmar</button>
            </div>
        </div>
    </div>

    <script src="js/map.js?v=123456789"></script>
    <script>
        // Load initial game data from original map.js structure
        let gameLocations = GAME_MAP;;

        let currentLocationId = null;
        let currentTab = 'basic';
        let currentPuzzleType = null;
        let autoSaveEnabled = false; // ‚ùå Auto-save DESABILITADO - apenas manual
        let locationOrder = []; // Track order of locations for drag-and-drop
        let draggedElement = null;

        // Visual positioning variables
        let selectedItemIndex = null;
        let selectedVisualType = null; // 'item' | 'puzzle' | 'wall' | null
        let selectedWallIndex = null;
        let draggedItem = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        const DEFAULT_VISUAL_TRANSFORM = {
            rotation: 0,
            rotateX: 0,
            rotateY: 0,
            scaleX: 1,
            scaleY: 1,
            skewX: 0,
            skewY: 0,
            flipX: false,
            flipY: false,
            opacity: 1,
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0
        };

        function cloneDefaultTransform() {
            return {
                rotation: DEFAULT_VISUAL_TRANSFORM.rotation,
                rotateX: DEFAULT_VISUAL_TRANSFORM.rotateX,
                rotateY: DEFAULT_VISUAL_TRANSFORM.rotateY,
                scaleX: DEFAULT_VISUAL_TRANSFORM.scaleX,
                scaleY: DEFAULT_VISUAL_TRANSFORM.scaleY,
                skewX: DEFAULT_VISUAL_TRANSFORM.skewX,
                skewY: DEFAULT_VISUAL_TRANSFORM.skewY,
                flipX: DEFAULT_VISUAL_TRANSFORM.flipX,
                flipY: DEFAULT_VISUAL_TRANSFORM.flipY,
                opacity: DEFAULT_VISUAL_TRANSFORM.opacity,
                shadowBlur: DEFAULT_VISUAL_TRANSFORM.shadowBlur,
                shadowOffsetX: DEFAULT_VISUAL_TRANSFORM.shadowOffsetX,
                shadowOffsetY: DEFAULT_VISUAL_TRANSFORM.shadowOffsetY
            };
        }

        function ensureItemDefaults(item) {
            if (!item) return;
            if (!item.position) item.position = { x: 50, y: 50 };
            if (!item.size) item.size = { width: 80, height: 80 };
            if (!item.transform) item.transform = cloneDefaultTransform();
        }

        function ensurePuzzleDefaults(puzzle) {
            if (!puzzle) return;
            if (!puzzle.visual) {
                puzzle.visual = {
                    beforeImage: '',
                    afterImage: '',
                    position: { x: 50, y: 50 },
                    size: { width: 120, height: 120 },
                    transform: cloneDefaultTransform()
                };
            } else {
                if (typeof puzzle.visual.beforeImage === 'undefined') {
                    puzzle.visual.beforeImage = '';
                }
                if (typeof puzzle.visual.afterImage === 'undefined') {
                    puzzle.visual.afterImage = '';
                }
                if (!puzzle.visual.position) {
                    puzzle.visual.position = { x: 50, y: 50 };
                }
                if (!puzzle.visual.size) {
                    puzzle.visual.size = { width: 120, height: 120 };
                }
                if (!puzzle.visual.transform) {
                    puzzle.visual.transform = cloneDefaultTransform();
                }
            }
        }

        function getSelectedVisual() {
            if (!currentLocationId) return null;
            const location = gameLocations[currentLocationId];
            if (!location) return null;

            if (selectedVisualType === 'item' && selectedItemIndex !== null && location.items) {
                const item = location.items[selectedItemIndex];
                if (!item) return null;
                ensureItemDefaults(item);
                return { type: 'item', data: item };
            }

            if (selectedVisualType === 'puzzle' && location.puzzle) {
                ensurePuzzleDefaults(location.puzzle);
                return { type: 'puzzle', data: location.puzzle.visual, puzzle: location.puzzle };
            }

            if (selectedVisualType === 'wall' && selectedWallIndex !== null && location.destructibleWalls) {
                return { type: 'wall', data: location.destructibleWalls[selectedWallIndex] };
            }

            if (selectedVisualType === 'digit' && selectedItemIndex !== null && location.puzzle?.digitPositions) {
                return { type: 'digit', data: location.puzzle.digitPositions[selectedItemIndex], index: selectedItemIndex };
            }

            if (selectedVisualType === 'hotspot' && selectedItemIndex !== null && location.hotspots) {
                const hotspot = location.hotspots[selectedItemIndex];
                if (!hotspot) return null;
                // Garantir que hotspot tenha transform
                if (!hotspot.transform) {
                    hotspot.transform = {
                        rotation: 0,
                        rotateX: 0,
                        rotateY: 0,
                        scaleX: 1,
                        scaleY: 1,
                        skewX: 0,
                        skewY: 0,
                        perspective: 800
                    };
                }
                return { type: 'hotspot', data: hotspot };
            }

            return null;
        }

        function highlightSelectedVisual() {
            const container = document.getElementById('visual-items-container');
            if (!container) return;
            Array.from(container.children).forEach(el => {
                const visualType = el.dataset.visualType || 'item';
                const indexAttr = el.dataset.itemIndex;
                const index = typeof indexAttr !== 'undefined' ? parseInt(indexAttr) : null;
                const isSelected =
                    (visualType === 'item' && selectedVisualType === 'item' && index === selectedItemIndex) ||
                    (visualType === 'puzzle' && selectedVisualType === 'puzzle');
                el.style.boxShadow = isSelected ? '0 0 0 3px #667eea' : 'none';
            });
        }

        // Drag and Drop functions
        function startDragItem(e) {
            e.preventDefault();
            e.stopPropagation();

            const target = e.currentTarget;
            const visualType = target.dataset.visualType;

            if (visualType === 'item') {
                selectedItemIndex = parseInt(target.dataset.itemIndex);
                selectedVisualType = 'item';
            } else if (visualType === 'puzzle') {
                selectedVisualType = 'puzzle';
                selectedItemIndex = null;
            } else if (visualType === 'wall') {
                selectedWallIndex = parseInt(target.dataset.wallIndex);
                selectedVisualType = 'wall';
            }

            draggedItem = target;

            const visualImage = document.getElementById('visual-location-image');
            const imgRect = visualImage.getBoundingClientRect();
            const targetRect = target.getBoundingClientRect();

            // Calculate offset from mouse to element center
            dragOffsetX = e.clientX - (targetRect.left + targetRect.width / 2);
            dragOffsetY = e.clientY - (targetRect.top + targetRect.height / 2);

            document.addEventListener('mousemove', onDragMove);
            document.addEventListener('mouseup', onDragEnd);

            renderTransformControls();
            highlightSelectedVisual();
        }

        function onDragMove(e) {
            if (!draggedItem) return;

            const visualImage = document.getElementById('visual-location-image');
            const imgRect = visualImage.getBoundingClientRect();

            // Calculate position relative to image
            const x = e.clientX - imgRect.left - dragOffsetX;
            const y = e.clientY - imgRect.top - dragOffsetY;

            // Convert to percentage
            const percentX = (x / imgRect.width) * 100;
            const percentY = (y / imgRect.height) * 100;

            // Clamp to image bounds
            const clampedX = Math.max(0, Math.min(100, percentX));
            const clampedY = Math.max(0, Math.min(100, percentY));

            // Update position
            const visual = getSelectedVisual();
            if (visual) {
                if (visual.type === 'item' || visual.type === 'puzzle') {
                    visual.data.position = { x: clampedX, y: clampedY };
                } else if (visual.type === 'wall') {
                    visual.data.x = clampedX;
                    visual.data.y = clampedY;
                }

                // Update visual immediately
                draggedItem.style.left = clampedX + '%';
                draggedItem.style.top = clampedY + '%';
            }
        }

        function onDragEnd(e) {
            if (!draggedItem) return;

            document.removeEventListener('mousemove', onDragMove);
            document.removeEventListener('mouseup', onDragEnd);

            draggedItem = null;

            // Save changes
            autoSave();
            renderTransformControls();
            highlightSelectedVisual();
        }

        // Toast notification function
        function showToast(message, type = 'success') {
            // Remove existing toast if any
            const existingToast = document.querySelector('.toast');
            if (existingToast) {
                existingToast.remove();
            }

            // Create toast element
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            // Show toast
            setTimeout(() => toast.classList.add('show'), 10);

            // Hide and remove toast after 1 second
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 1000);
        }

        // Initialize
        window.onload = async function () {
            // Tentar carregar do IndexedDB primeiro (fonte da verdade)
            const indexedDBData = await loadFromIndexedDB('editorData');
            if (indexedDBData && indexedDBData.locations && Object.keys(indexedDBData.locations).length > 0) {
                console.log('üì¶ Carregando do IndexedDB (fonte da verdade)');
                gameLocations = indexedDBData.locations;
                locationOrder = indexedDBData.order || Object.keys(gameLocations);
                renderLocationsList();
            } else {
                // Se IndexedDB vazio, carregar do MySQL
                console.log('üîÑ IndexedDB vazio, carregando do MySQL...');
                await loadFromDatabase(true);
            }
        };

        // ‚ùå AUTO-SAVE DESABILITADO - Apenas salvamento manual
        /*
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (autoSaveTimer) {
                    clearTimeout(autoSaveTimer);
                    syncToDatabase(true).catch(err => console.error('Sync error:', err));
                }
            }
        });

        window.addEventListener('beforeunload', () => {
            if (autoSaveTimer) {
                clearTimeout(autoSaveTimer);
                syncToDatabase(true).catch(err => console.error('Sync error:', err));
            }
        });
        */

        // Initialize location order
        function initializeLocationOrder() {
            locationOrder = Object.keys(gameLocations);
        }

        // Debounce timer for database sync
        let autoSaveTimer = null;
        const SYNC_DEBOUNCE_MS = 500; // 500ms de debounce (sync mais r√°pido)

        // Auto-save to localStorage
        async function autoSave() {
            if (!autoSaveEnabled) return; // ‚úÖ N√£o fazer nada se auto-save desabilitado

            const saveData = {
                locations: gameLocations,
                order: locationOrder
            };
            try {
                // Salvar localmente imediatamente
                await saveToIndexedDB('editorData', saveData);
                // Marcar que h√° mudan√ßas n√£o sincronizadas
                localStorage.setItem('unsyncedChanges', 'true');
                // showSaveIndicator(); // Removido daqui para evitar piscar excessivo

                // Debounce para sincroniza√ß√£o com banco de dados
                if (autoSaveTimer) {
                    clearTimeout(autoSaveTimer);
                }

                autoSaveTimer = setTimeout(async () => {
                    try {
                        await syncToDatabase(true); // true = silent mode
                        showSaveIndicator(); // Mostrar apenas quando sincronizar
                    } catch (error) {
                        console.error('‚ùå Erro na sincroniza√ß√£o:', error);
                    }
                }, SYNC_DEBOUNCE_MS);
            } catch (e) {
                console.error('Erro ao salvar:', e);
            }
        }

        async function loadFromLocalStorage() {
            try {
                const saveData = await loadFromIndexedDB('editorData');
                if (saveData) {
                    if (saveData.locations) {
                        gameLocations = saveData.locations;
                        if (saveData.order) {
                            locationOrder = saveData.order;
                        } else {
                            initializeLocationOrder();
                        }
                    } else {
                        // Old format compatibility
                        gameLocations = saveData;
                        initializeLocationOrder();
                    }
                    renderLocationsList();

                    // ‚úÖ Verificar par√¢metros da URL primeiro (vindo do map-editor)
                    const urlParams = new URLSearchParams(window.location.search);
                    const urlLocation = urlParams.get('location');
                    const urlTab = urlParams.get('tab');

                    let locationToLoad = null;

                    if (urlLocation) {
                        // Se veio da URL (map-editor), usar sempre esse e limpar cache
                        locationToLoad = urlLocation;
                        // Limpar cache para evitar conflito
                        localStorage.removeItem('editor_current_location');
                        localStorage.removeItem('editor_last_location');
                    } else {
                        // Restaurar do cache apenas se N√ÉO veio da URL
                        const currentLocation = localStorage.getItem('editor_current_location');
                        const lastLocation = localStorage.getItem('editor_last_location');
                        locationToLoad = lastLocation || currentLocation;
                    }

                    if (locationToLoad && gameLocations[locationToLoad]) {
                        // Pequeno delay para garantir que a lista foi renderizada
                        setTimeout(() => {
                            selectLocation(locationToLoad);

                            // Apenas limpar editor_last_location se n√£o veio da URL
                            if (!urlLocation) {
                                localStorage.removeItem('editor_last_location');
                            }

                            // ‚úÖ Se veio da URL com tab=visual, trocar para aba de posicionamento visual
                            if (urlTab === 'visual') {
                                // Delay maior para garantir que a localiza√ß√£o foi carregada antes de trocar aba
                                setTimeout(() => {
                                    switchTab('visual');
                                }, 200);
                            }
                        }, 100);
                    }
                } else {
                }
            } catch (e) {
                console.error('Erro ao carregar dados salvos:', e);
            }
        }

        let saveIndicatorTimer = null;
        function showSaveIndicator() {
            const indicator = document.getElementById('saveIndicator');
            indicator.classList.add('show');

            if (saveIndicatorTimer) {
                clearTimeout(saveIndicatorTimer);
            }

            saveIndicatorTimer = setTimeout(() => {
                indicator.classList.remove('show');
                saveIndicatorTimer = null;
            }, 2000);
        }

        // Render locations list
        function renderLocationsList() {

            const list = document.getElementById('locationsList');
            list.innerHTML = '';

            locationOrder.forEach((locationId, index) => {
                const location = gameLocations[locationId];
                if (!location) return; // Skip if location doesn't exist

                const item = document.createElement('div');
                item.className = 'location-item' + (currentLocationId === location.id ? ' active' : '');
                item.draggable = true;
                item.dataset.locationId = location.id;
                item.dataset.index = index;

                item.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="cursor: grab; opacity: 0.5;">‚ò∞</div>
                        <div>
                            <div class="location-item-name">${location.name}</div>
                            <div class="location-item-id">${location.id}</div>
                        </div>
                    </div>
                    <button class="delete-location-btn" onclick="deleteLocation('${location.id}'); event.stopPropagation();">üóëÔ∏è</button>
                `;

                // Drag and drop event handlers
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('drop', handleDrop);
                item.addEventListener('dragend', handleDragEnd);

                item.onclick = (e) => {
                    if (!e.target.classList.contains('delete-location-btn')) {
                        selectLocation(location.id);
                    }
                };

                list.appendChild(item);
            });
        }

        // Drag and drop handlers
        function handleDragStart(e) {
            draggedElement = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';

            // Remove drag-over class from all items
            document.querySelectorAll('.location-item').forEach(item => {
                item.classList.remove('drag-over');
            });

            // Add drag-over class to current target
            const targetItem = e.target.closest('.location-item');
            if (targetItem && targetItem !== draggedElement) {
                targetItem.classList.add('drag-over');
            }

            return false;
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            const targetItem = this;
            if (draggedElement !== targetItem) {
                const draggedIndex = parseInt(draggedElement.dataset.index);
                const targetIndex = parseInt(targetItem.dataset.index);

                // Reorder the locationOrder array
                const draggedId = locationOrder[draggedIndex];
                locationOrder.splice(draggedIndex, 1);
                locationOrder.splice(targetIndex, 0, draggedId);

                // Re-render and save
                renderLocationsList();
                syncToDatabase(true); // silent sync
            }

            return false;
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.location-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        // Select location
        function selectLocation(locationId) {
            currentLocationId = locationId;
            // Salvar localiza√ß√£o atual para restaurar ap√≥s F5
            localStorage.setItem('editor_current_location', locationId);
            renderLocationsList();
            loadLocationData();
        }

        // Load location data into editor
        function loadLocationData() {
            if (!currentLocationId) return;

            const location = gameLocations[currentLocationId];
            document.getElementById('currentLocationName').textContent = location.name;
            document.getElementById('currentLocationId').textContent = location.id;

            // Basic info
            document.getElementById('edit-id').value = location.id;
            document.getElementById('edit-name').value = location.name;
            document.getElementById('edit-description').value = location.description;
            document.getElementById('edit-image').value = location.image;
            document.getElementById('edit-unlocked').checked = location.unlocked || false;
            document.getElementById('edit-final-scene').checked = location.isFinalScene || false;
            document.getElementById('edit-transition-video').value = location.transitionVideo || '';
            document.getElementById('edit-dramatic-messages').value = location.dramaticMessages || '';
            document.getElementById('edit-dramatic-duration').value = location.dramaticMessageDuration || 5;
            toggleCreditsSection();

            // Carregar cr√©ditos se existirem
            if (location.isFinalScene && location.credits) {
                loadCreditsData(location.credits);
            } else {
                document.getElementById('credits-list').innerHTML = '';
            }

            // Puzzle - LIMPAR PRIMEIRO, depois carregar
            const hasPuzzle = !!location.puzzle;

            // üîß SEMPRE limpar campos ANTES de carregar (previne dados fantasmas)
            clearPuzzleFormFields();

            // ‚ö° Setar checkbox SEM disparar onchange (previne save indevido)
            const puzzleCheckbox = document.getElementById('has-puzzle');
            const originalOnChange = puzzleCheckbox.onchange;
            puzzleCheckbox.onchange = null;  // Desabilita temporariamente
            puzzleCheckbox.checked = hasPuzzle;
            puzzleCheckbox.onchange = originalOnChange;  // Restaura

            // Mostrar/ocultar editor SEM salvar
            document.getElementById('puzzle-editor').style.display = hasPuzzle ? 'block' : 'none';

            // Carregar dados do puzzle da localiza√ß√£o atual
            if (hasPuzzle) {
                loadPuzzleData(location.puzzle);
            }

            // Reset visual selections ao trocar de local
            selectedVisualType = null;
            selectedItemIndex = null;

            // Items
            renderItemsList();

            // Hotspots
            renderHotspotsList();

            // Connections
            renderConnectionsList();

            // Walls
            renderDestructibleWallsList();

            // Image preview
            loadImagePreview();

            // Visual editor
            loadVisualEditor();
        }

        // Load image preview in basic tab
        function loadImagePreview() {
            const location = gameLocations[currentLocationId];
            if (location && location.imageData) {
                document.getElementById('location-image-preview').style.display = 'block';
                document.getElementById('location-preview-img').src = location.imageData;
            } else if (location && location.image) {
                document.getElementById('location-image-preview').style.display = 'block';
                document.getElementById('location-preview-img').src = location.image;
            } else {
                document.getElementById('location-image-preview').style.display = 'none';
            }
        }

        // Handle location image upload
        function handleLocationImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const location = gameLocations[currentLocationId];
            const imagePath = `images/${file.name}`;

            location.image = imagePath;
            delete location.imageData; // Remove embedded image data

            // Update preview
            document.getElementById('location-image-preview').style.display = 'block';
            document.getElementById('location-preview-img').src = imagePath;

            // Update the input field with the new path
            document.getElementById('edit-image').value = imagePath;

            // Update visual editor
            loadVisualEditor();

            autoSave();
            showToast('‚úì Imagem carregada com sucesso!');
        }

        // Load visual editor
        function loadVisualEditor() {
            if (!currentLocationId) return;

            const location = gameLocations[currentLocationId];
            const visualImage = document.getElementById('visual-location-image');
            const noImageDiv = document.getElementById('visual-no-image');

            if (location.image) {
                visualImage.src = location.image;
                visualImage.style.display = 'block';
                noImageDiv.style.display = 'none';

                // Salvar dimens√µes se ainda n√£o existirem
                visualImage.onload = function () {
                    if (!location.imageDimensions) {
                        location.imageDimensions = {
                            width: visualImage.naturalWidth,
                            height: visualImage.naturalHeight
                        };
                    }
                    renderPositionedItems();
                    renderPositionedHotspots();
                    renderPositionedWalls();
                };

                // Render items list
                renderVisualItemsList();
                renderVisualHotspotsList();
                renderVisualWallsList();

                // Wait for image to load before rendering items
                if (visualImage.complete) {
                    if (!location.imageDimensions) {
                        location.imageDimensions = {
                            width: visualImage.naturalWidth,
                            height: visualImage.naturalHeight
                        };
                    }
                    renderPositionedItems();
                    renderPositionedHotspots();
                    renderPositionedWalls();
                }

            } else {
                visualImage.style.display = 'none';
                noImageDiv.style.display = 'block';
            }
        }

        // Render visual items list
        function renderVisualItemsList() {
            if (!currentLocationId) return;

            const location = gameLocations[currentLocationId];
            const list = document.getElementById('visual-items-list');

            list.innerHTML = '';

            const hasItems = Array.isArray(location.items) && location.items.length > 0;
            if (!hasItems) {
                const emptyInfo = document.createElement('p');
                emptyInfo.style.cssText = 'color: #999; font-size: 14px; margin-bottom: 15px;';
                emptyInfo.textContent = 'Nenhum item. Adicione itens na aba "Itens".';
                list.appendChild(emptyInfo);
            } else {
                location.items.forEach((item, index) => {
                    ensureItemDefaults(item);

                    const itemDiv = document.createElement('div');
                    itemDiv.style.cssText = 'background: white; padding: 10px; margin-bottom: 10px; border-radius: 6px; border: 2px solid #e0e0e0;';

                    itemDiv.innerHTML = `
                        <div style="font-weight: 600; margin-bottom: 8px;">${item.name}</div>
                        <input type="file"
                               id="item-image-${index}"
                               accept="image/png,image/gif"
                               style="display: none;"
                               onchange="handleItemImageUpload(${index}, event)">
                        <button class="btn btn-secondary btn-small"
                                style="width: 100%; margin-bottom: 5px;"
                                onclick="document.getElementById('item-image-${index}').click()">
                            ${item.image ? '‚úì Alterar Imagem' : 'üìÅ Upload PNG/GIF'}
                        </button>
                        ${item.image ? `
                            <div style="text-align: center; margin-top: 8px;">
                                <img src="${item.image}" style="max-width: 100%; max-height: 80px; image-rendering: crisp-edges;">
                                <div style="font-size: 11px; color: #999; margin-top: 5px;">
                                    ${item.position ? `Posi√ß√£o: ${item.position.x.toFixed(1)}%, ${item.position.y.toFixed(1)}%` : 'Arraste para posicionar'}
                                </div>
                            </div>
                        ` : ''}
                    `;

                    list.appendChild(itemDiv);
                });
            }

            if (location.puzzle) {
                ensurePuzzleDefaults(location.puzzle);
                const puzzleVisual = location.puzzle.visual;

                const puzzleDiv = document.createElement('div');
                puzzleDiv.style.cssText = 'background: #fff6e5; padding: 12px; border-radius: 8px; border: 2px solid #f0a500;';

                puzzleDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong style="font-size: 15px;">üß© Visual do Enigma</strong>
                        <span style="font-size: 12px; color: #b36b00;">Ba√∫ fechado / aberto</span>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        <div style="background: white; border: 1px solid #f0a500; border-radius: 6px; padding: 8px; text-align: center;">
                            <div style="font-weight: 600; font-size: 13px; margin-bottom: 8px;">Antes (fechado)</div>
                            <input type="file" id="puzzle-image-before" accept="image/png" style="display: none;" onchange="handlePuzzleImageUpload('before', event)">
                            <button class="btn btn-secondary btn-small" style="width: 100%; margin-bottom: 6px;"
                                    onclick="document.getElementById('puzzle-image-before').click()">
                                ${puzzleVisual.beforeImage ? '‚úì Alterar PNG' : 'üìÅ Upload PNG'}
                            </button>
                            ${puzzleVisual.beforeImage ? `<img src="${puzzleVisual.beforeImage}" style="max-width: 100%; max-height: 90px; image-rendering: crisp-edges;">` : '<div style="font-size: 12px; color: #999;">Sem imagem</div>'}
                        </div>

                        <div style="background: white; border: 1px solid #f0a500; border-radius: 6px; padding: 8px; text-align: center;">
                            <div style="font-weight: 600; font-size: 13px; margin-bottom: 8px;">Depois (aberto)</div>
                            <input type="file" id="puzzle-image-after" accept="image/png" style="display: none;" onchange="handlePuzzleImageUpload('after', event)">
                            <button class="btn btn-secondary btn-small" style="width: 100%; margin-bottom: 6px;"
                                    onclick="document.getElementById('puzzle-image-after').click()">
                                ${puzzleVisual.afterImage ? '‚úì Alterar PNG' : 'üìÅ Upload PNG'}
                            </button>
                            ${puzzleVisual.afterImage ? `<img src="${puzzleVisual.afterImage}" style="max-width: 100%; max-height: 90px; image-rendering: crisp-edges;">` : '<div style="font-size: 12px; color: #999;">Sem imagem</div>'}
                        </div>
                    </div>

                    <div style="margin-top: 10px; font-size: 11px; color: #805400; line-height: 1.4;">
                        ‚ûï Ap√≥s enviar as imagens, selecione o enigma no cen√°rio e ajuste posi√ß√£o/tamanho na pr√©-visualiza√ß√£o.
                    </div>
                    <button class="btn btn-primary btn-small" style="width: 100%; margin-top: 10px;"
                            onclick="selectPuzzleVisual(); renderPositionedItems();">
                        üéØ Selecionar Enigma no Cen√°rio
                    </button>
                `;

                list.appendChild(puzzleDiv);
            }
        }

        // Handle item image upload
        function handleItemImageUpload(itemIndex, event) {
            const file = event.target.files[0];
            if (!file) return;

            event.target.value = '';

            const location = gameLocations[currentLocationId];
            const item = location.items[itemIndex];

            // ‚úÖ Usar images/objects para decorativos, images/items para colecion√°veis
            const folder = item.isDecorative ? 'images/objects' : 'images/items';
            const imagePath = `${folder}/${file.name}`;

            // Save as image path reference (not base64 data)
            location.items[itemIndex].image = imagePath;
            delete location.items[itemIndex].imageData; // Remove old embedded image data if exists

            // Set default size if not set
            if (!location.items[itemIndex].size) {
                location.items[itemIndex].size = { width: 80, height: 80 };
            }

            // Set default position if not set (center of canvas)
            if (!location.items[itemIndex].position) {
                location.items[itemIndex].position = { x: 50, y: 50 };
            }

            renderVisualItemsList();
            renderPositionedItems();
            autoSave();

            showToast('‚úì Imagem de item carregada!');
        }

        function handleWallImageUpload(wallIndex, event) {
            const file = event.target.files[0];
            if (!file) return;

            event.target.value = '';

            const location = gameLocations[currentLocationId];
            const imagePath = `images/walls/${file.name}`;

            // Save as image path reference
            if (!location.destructibleWalls) {
                location.destructibleWalls = [];
            }
            location.destructibleWalls[wallIndex].image = imagePath;

            renderVisualWallsList();
            renderPositionedWalls();
            renderTransformControls();
            autoSave();

            showToast('‚úì Imagem de parede carregada!');
        }

        async function autoPositionWall(wallIndex) {
            if (!currentLocationId || wallIndex === null) return;

            const location = gameLocations[currentLocationId];
            const wall = location.destructibleWalls[wallIndex];

            if (!wall.image || !location.image) {
                showToast('‚ùå Necess√°rio ter imagem da parede e do cen√°rio!', 'error');
                return;
            }

            showToast('ü§ñ Analisando... aguarde', 'info');

            try {
                // Carregar imagens
                const bgImage = await loadImage(location.image);
                const wallImage = await loadImage(wall.image);

                // Criar canvas para processamento
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                // Template matching - procurar melhor posi√ß√£o
                const result = findBestMatch(bgImage, wallImage, ctx);

                if (result) {
                    // Converter pixels para porcentagem
                    const xPercent = (result.x / bgImage.width) * 100;
                    const yPercent = (result.y / bgImage.height) * 100;
                    const widthPercent = (result.width / bgImage.width) * 100;
                    const heightPercent = (result.height / bgImage.height) * 100;

                    // Atualizar posi√ß√£o da parede
                    wall.x = Math.round(xPercent * 10) / 10;
                    wall.y = Math.round(yPercent * 10) / 10;
                    wall.width = Math.round(widthPercent * 10) / 10;
                    wall.height = Math.round(heightPercent * 10) / 10;

                    // Atualizar visualiza√ß√£o
                    renderPositionedWalls();
                    renderTransformControls();
                    renderVisualWallsList();
                    renderDestructibleWallsList();
                    autoSave();

                    showToast(`‚úÖ Parede posicionada! Confian√ßa: ${Math.round(result.confidence * 100)}%`);
                } else {
                    showToast('‚ùå N√£o foi poss√≠vel encontrar posi√ß√£o autom√°tica', 'error');
                }
            } catch (err) {
                showToast('‚ùå Erro ao processar: ' + err.message, 'error');
                console.error('Erro no auto-posicionamento:', err);
            }
        }

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('Falha ao carregar imagem: ' + src));
                img.src = src;
            });
        }

        function findBestMatch(bgImage, templateImage, ctx) {
            const bgWidth = bgImage.width;
            const bgHeight = bgImage.height;
            const tplWidth = templateImage.width;
            const tplHeight = templateImage.height;

            // FASE 1: Busca grossa (r√°pida)
            const coarseScale = 0.25;
            const coarseResult = coarseSearch(bgImage, templateImage, coarseScale);

            if (!coarseResult) return null;

            // FASE 2: Busca fina ao redor do melhor resultado (precisa)
            const fineScale = 0.5;
            const searchRadius = 50; // pixels na escala original
            const fineResult = fineSearch(
                bgImage, templateImage,
                coarseResult.x, coarseResult.y,
                searchRadius, fineScale
            );

            if (!fineResult) return coarseResult;

            return fineResult;
        }

        function coarseSearch(bgImage, templateImage, scale) {
            const bgWidth = bgImage.width;
            const bgHeight = bgImage.height;
            const tplWidth = templateImage.width;
            const tplHeight = templateImage.height;

            const scaledBgW = Math.floor(bgWidth * scale);
            const scaledBgH = Math.floor(bgHeight * scale);
            const scaledTplW = Math.floor(tplWidth * scale);
            const scaledTplH = Math.floor(tplHeight * scale);

            const bgCanvas = document.createElement('canvas');
            bgCanvas.width = scaledBgW;
            bgCanvas.height = scaledBgH;
            const bgCtx = bgCanvas.getContext('2d');
            bgCtx.drawImage(bgImage, 0, 0, scaledBgW, scaledBgH);
            const bgData = bgCtx.getImageData(0, 0, scaledBgW, scaledBgH);

            const tplCanvas = document.createElement('canvas');
            tplCanvas.width = scaledTplW;
            tplCanvas.height = scaledTplH;
            const tplCtx = tplCanvas.getContext('2d');
            tplCtx.drawImage(templateImage, 0, 0, scaledTplW, scaledTplH);
            const tplData = tplCtx.getImageData(0, 0, scaledTplW, scaledTplH);

            let bestScore = -Infinity;
            let bestX = 0;
            let bestY = 0;

            const stepSize = 8; // Maior step = mais r√°pido
            for (let y = 0; y < scaledBgH - scaledTplH; y += stepSize) {
                for (let x = 0; x < scaledBgW - scaledTplW; x += stepSize) {
                    const score = calculateEdgeSimilarity(
                        bgData, tplData, x, y,
                        scaledBgW, scaledBgH, scaledTplW, scaledTplH
                    );

                    if (score > bestScore) {
                        bestScore = score;
                        bestX = x;
                        bestY = y;
                    }
                }
            }

            const finalX = Math.round(bestX / scale);
            const finalY = Math.round(bestY / scale);
            const confidence = Math.min(1, Math.max(0, bestScore / 255));

            if (confidence < 0.2) return null;

            return {
                x: finalX,
                y: finalY,
                width: tplWidth,
                height: tplHeight,
                confidence: confidence
            };
        }

        function fineSearch(bgImage, templateImage, centerX, centerY, radius, scale) {
            const bgWidth = bgImage.width;
            const bgHeight = bgImage.height;
            const tplWidth = templateImage.width;
            const tplHeight = templateImage.height;

            const scaledBgW = Math.floor(bgWidth * scale);
            const scaledBgH = Math.floor(bgHeight * scale);
            const scaledTplW = Math.floor(tplWidth * scale);
            const scaledTplH = Math.floor(tplHeight * scale);

            const bgCanvas = document.createElement('canvas');
            bgCanvas.width = scaledBgW;
            bgCanvas.height = scaledBgH;
            const bgCtx = bgCanvas.getContext('2d');
            bgCtx.drawImage(bgImage, 0, 0, scaledBgW, scaledBgH);
            const bgData = bgCtx.getImageData(0, 0, scaledBgW, scaledBgH);

            const tplCanvas = document.createElement('canvas');
            tplCanvas.width = scaledTplW;
            tplCanvas.height = scaledTplH;
            const tplCtx = tplCanvas.getContext('2d');
            tplCtx.drawImage(templateImage, 0, 0, scaledTplW, scaledTplH);
            const tplData = tplCtx.getImageData(0, 0, scaledTplW, scaledTplH);

            // Definir √°rea de busca
            const scaledCenterX = Math.floor(centerX * scale);
            const scaledCenterY = Math.floor(centerY * scale);
            const scaledRadius = Math.floor(radius * scale);

            const minX = Math.max(0, scaledCenterX - scaledRadius);
            const maxX = Math.min(scaledBgW - scaledTplW, scaledCenterX + scaledRadius);
            const minY = Math.max(0, scaledCenterY - scaledRadius);
            const maxY = Math.min(scaledBgH - scaledTplH, scaledCenterY + scaledRadius);

            let bestScore = -Infinity;
            let bestX = scaledCenterX;
            let bestY = scaledCenterY;

            // Busca refinada pixel a pixel
            for (let y = minY; y < maxY; y += 1) {
                for (let x = minX; x < maxX; x += 1) {
                    const score = calculateEdgeSimilarity(
                        bgData, tplData, x, y,
                        scaledBgW, scaledBgH, scaledTplW, scaledTplH
                    );

                    if (score > bestScore) {
                        bestScore = score;
                        bestX = x;
                        bestY = y;
                    }
                }
            }

            const finalX = Math.round(bestX / scale);
            const finalY = Math.round(bestY / scale);
            const confidence = Math.min(1, Math.max(0, bestScore / 255));

            return {
                x: finalX,
                y: finalY,
                width: tplWidth,
                height: tplHeight,
                confidence: confidence
            };
        }

        function calculateEdgeSimilarity(bgData, tplData, offsetX, offsetY, bgW, bgH, tplW, tplH) {
            let sumDiff = 0;
            let count = 0;

            // Amostrar apenas bordas (mais r√°pido e eficiente)
            const borderSize = Math.min(20, Math.floor(tplW * 0.2)); // 20% das bordas

            // Borda superior e inferior
            for (let x = 0; x < tplW; x += 2) {
                // Top
                for (let y = 0; y < borderSize; y += 2) {
                    sumDiff += comparePixels(bgData, tplData, offsetX + x, offsetY + y, x, y, bgW, tplW);
                    count++;
                }
                // Bottom
                for (let y = tplH - borderSize; y < tplH; y += 2) {
                    sumDiff += comparePixels(bgData, tplData, offsetX + x, offsetY + y, x, y, bgW, tplW);
                    count++;
                }
            }

            // Borda esquerda e direita
            for (let y = borderSize; y < tplH - borderSize; y += 2) {
                // Left
                for (let x = 0; x < borderSize; x += 2) {
                    sumDiff += comparePixels(bgData, tplData, offsetX + x, offsetY + y, x, y, bgW, tplW);
                    count++;
                }
                // Right
                for (let x = tplW - borderSize; x < tplW; x += 2) {
                    sumDiff += comparePixels(bgData, tplData, offsetX + x, offsetY + y, x, y, bgW, tplW);
                    count++;
                }
            }

            // Retornar score m√©dio (menor diferen√ßa = melhor match)
            // Inverter para que maior = melhor
            return count > 0 ? 255 - (sumDiff / count) : 0;
        }

        function comparePixels(bgData, tplData, bgX, bgY, tplX, tplY, bgW, tplW) {
            const bgIdx = (bgY * bgW + bgX) * 4;
            const tplIdx = (tplY * tplW + tplX) * 4;

            // Comparar RGB (ignorar alpha)
            const rDiff = Math.abs(bgData.data[bgIdx] - tplData.data[tplIdx]);
            const gDiff = Math.abs(bgData.data[bgIdx + 1] - tplData.data[tplIdx + 1]);
            const bDiff = Math.abs(bgData.data[bgIdx + 2] - tplData.data[tplIdx + 2]);

            return (rDiff + gDiff + bDiff) / 3;
        }

        function handlePuzzleImageUpload(state, event) {
            if (!currentLocationId) return;

            const file = event.target.files[0];
            event.target.value = '';
            if (!file) return;

            const location = gameLocations[currentLocationId];
            if (!location.puzzle) {
                showToast('Configure o enigma antes de adicionar imagens', 'warning');
                return;
            }

            ensurePuzzleDefaults(location.puzzle);

            const imagePath = `images/puzzles/${file.name}`;
            if (state === 'after') {
                location.puzzle.visual.afterImage = imagePath;
            } else {
                location.puzzle.visual.beforeImage = imagePath;
            }

            renderVisualItemsList();
            renderPositionedItems();
            autoSave();

            showToast('‚úì Imagem do enigma atualizada!');
        }

        // Ajustar escala do container no editor
        function adjustEditorContainer() {
            const visualImage = document.getElementById('visual-location-image');
            const container = document.getElementById('visual-items-container');

            if (!visualImage || !container) return;

            const imgRect = visualImage.getBoundingClientRect();
            const naturalWidth = visualImage.naturalWidth || imgRect.width;
            const naturalHeight = visualImage.naturalHeight || imgRect.height;
            const scale = imgRect.width / naturalWidth;

            container.style.width = naturalWidth + 'px';
            container.style.height = naturalHeight + 'px';
            container.style.transform = `scale(${scale})`;
            container.style.transformOrigin = 'top left';
        }

        // Render positioned walls on the visual editor
        // Render positioned items on the image
        function renderPadlockDigitBoxes(puzzle, container) {
            // Garantir que digitPositions existe
            if (!puzzle.digitPositions) {
                puzzle.digitPositions = [
                    { x: puzzle.visual.position.x - 8, y: puzzle.visual.position.y + 12 },
                    { x: puzzle.visual.position.x - 4, y: puzzle.visual.position.y + 12 },
                    { x: puzzle.visual.position.x, y: puzzle.visual.position.y + 12 },
                    { x: puzzle.visual.position.x + 4, y: puzzle.visual.position.y + 12 },
                    { x: puzzle.visual.position.x + 8, y: puzzle.visual.position.y + 12 }
                ];
            }

            const digitSize = puzzle.digitSize || { width: 40, height: 50 };

            puzzle.digitPositions.forEach((pos, index) => {
                const isSelected = selectedVisualType === 'digit' && selectedItemIndex === index;

                const digitEl = document.createElement('div');
                digitEl.dataset.visualType = 'digit';
                digitEl.dataset.digitIndex = index;
                digitEl.style.cssText = `
                    position: absolute;
                    left: ${pos.x}%;
                    top: ${pos.y}%;
                    width: ${digitSize.width}px;
                    height: ${digitSize.height}px;
                    transform: translate(-50%, -50%);
                    cursor: move;
                    pointer-events: auto;
                    z-index: 130;
                    background: rgba(0, 0, 0, 0.7);
                    border: 3px solid ${isSelected ? '#00ff00' : '#f0a500'};
                    border-radius: 8px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 24px;
                    font-weight: bold;
                    color: #f0a500;
                    ${isSelected ? 'box-shadow: 0 0 0 3px #00ff00;' : ''}
                `;
                digitEl.textContent = index.toString();

                const label = document.createElement('div');
                label.textContent = `D√≠gito ${index + 1}`;
                label.style.cssText = `
                    position: absolute;
                    bottom: -25px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 255, 0, 0.9);
                    color: #000;
                    padding: 4px 8px;
                    font-size: 10px;
                    border-radius: 4px;
                    white-space: nowrap;
                    pointer-events: none;
                    font-weight: 600;
                `;
                digitEl.appendChild(label);

                digitEl.addEventListener('mousedown', startDragItem);

                container.appendChild(digitEl);
            });
        }

        function renderShapeMatchMoldBoxes(puzzle, container) {
            // Garantir que molds existe
            if (!puzzle.molds || !Array.isArray(puzzle.molds)) {
                puzzle.molds = [];
                return;
            }

            const shapeIcons = {
                'circle': '‚≠ï',
                'square': '‚¨ú',
                'triangle': 'üî∫',
                'rectangle': '‚ñ≠',
                'star': '‚≠ê'
            };

            puzzle.molds.forEach((mold, index) => {
                const isSelected = selectedVisualType === 'mold' && selectedItemIndex === index;

                // ‚úÖ Posi√ß√µes j√° s√£o armazenadas em porcentagem (0-100+)
                // N√£o converter mais, pois causa bug quando % > 100
                const moldX = mold.x || 50;
                const moldY = mold.y || 50;

                const moldEl = document.createElement('div');
                moldEl.dataset.visualType = 'mold';
                moldEl.dataset.moldIndex = index;
                moldEl.style.cssText = `
                    position: absolute;
                    left: ${moldX}%;
                    top: ${moldY}%;
                    width: 60px;
                    height: 60px;
                    transform: translate(-50%, -50%);
                    cursor: move;
                    pointer-events: auto;
                    z-index: 130;
                    background: rgba(139, 111, 71, 0.7);
                    border: 3px solid ${isSelected ? '#00ff00' : '#d4af37'};
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 32px;
                    ${isSelected ? 'box-shadow: 0 0 0 3px #00ff00;' : ''}
                `;
                moldEl.textContent = shapeIcons[mold.shape] || 'üî∑';

                const label = document.createElement('div');
                label.textContent = `${mold.shape || 'circle'} - ${mold.item || 'nenhum'}`;
                label.style.cssText = `
                    position: absolute;
                    bottom: -30px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(212, 175, 55, 0.9);
                    color: #000;
                    padding: 4px 8px;
                    font-size: 10px;
                    border-radius: 4px;
                    white-space: nowrap;
                    pointer-events: none;
                    font-weight: 600;
                    max-width: 120px;
                    overflow: hidden;
                    text-overflow: ellipsis;
                `;
                moldEl.appendChild(label);

                moldEl.addEventListener('mousedown', startDragItem);

                container.appendChild(moldEl);
            });
        }

        function renderPositionedItems() {
            if (!currentLocationId) return;

            const location = gameLocations[currentLocationId];
            const container = document.getElementById('visual-items-container');

            if (!container) {
                console.error('Container visual-items-container n√£o encontrado!');
                return;
            }

            // Ajustar escala do container
            adjustEditorContainer();

            container.innerHTML = '';

            if (!Array.isArray(location.items)) {
                location.items = [];
            }

            if (location.puzzle) {
                ensurePuzzleDefaults(location.puzzle);
                const puzzleVisual = location.puzzle.visual;
                const isPuzzleSelected = selectedVisualType === 'puzzle';

                const transforms = [
                    'translate(-50%, -50%)',
                    `rotateZ(${puzzleVisual.transform.rotation || 0}deg)`,
                    `rotateX(${puzzleVisual.transform.rotateX || 0}deg)`,
                    `rotateY(${puzzleVisual.transform.rotateY || 0}deg)`,
                    `scaleX(${(puzzleVisual.transform.scaleX || 1) * (puzzleVisual.transform.flipX ? -1 : 1)})`,
                    `scaleY(${(puzzleVisual.transform.scaleY || 1) * (puzzleVisual.transform.flipY ? -1 : 1)})`,
                    `skewX(${puzzleVisual.transform.skewX || 0}deg)`,
                    `skewY(${puzzleVisual.transform.skewY || 0}deg)`
                ];

                const shadowBlur = puzzleVisual.transform.shadowBlur || 0;
                const shadowX = puzzleVisual.transform.shadowOffsetX || 0;
                const shadowY = puzzleVisual.transform.shadowOffsetY || 0;
                const filterString = shadowBlur > 0
                    ? `drop-shadow(${shadowX}px ${shadowY}px ${shadowBlur}px rgba(0,0,0,0.5))`
                    : 'none';

                const puzzleEl = document.createElement('div');
                puzzleEl.dataset.visualType = 'puzzle';
                puzzleEl.style.cssText = `
                    position: absolute;
                    left: ${puzzleVisual.position.x}%;
                    top: ${puzzleVisual.position.y}%;
                    transform: ${transforms.join(' ')};
                    cursor: move;
                    pointer-events: auto;
                    z-index: 120;
                    opacity: ${puzzleVisual.transform.opacity || 1};
                    filter: ${filterString};
                    ${isPuzzleSelected ? 'box-shadow: 0 0 0 3px #f0a500;' : ''}
                `;

                // ‚úÖ Usar <img> em tamanho original (auto) - scale controlado por transform
                if (puzzleVisual.beforeImage) {
                    const img = document.createElement('img');
                    img.src = puzzleVisual.beforeImage;
                    img.style.cssText = `
                        display: block;
                        width: auto;
                        height: auto;
                        max-width: none;
                        pointer-events: none;
                        image-rendering: crisp-edges;
                    `;
                    puzzleEl.appendChild(img);
                } else {
                    // Fallback: mostrar √°rea de placeholder
                    puzzleEl.style.cssText += `
                        width: ${puzzleVisual.size.width}px;
                        height: ${puzzleVisual.size.height}px;
                        background: repeating-linear-gradient(45deg, rgba(240,165,0,0.3), rgba(240,165,0,0.3) 10px, rgba(255,255,255,0.1) 10px, rgba(255,255,255,0.1) 20px);
                        border: 3px dashed #f0a500;
                        border-radius: 6px;
                    `;
                }

                const label = document.createElement('div');
                label.textContent = location.puzzle.id || 'Enigma';
                label.style.cssText = `
                    position: absolute;
                    bottom: -25px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(240, 165, 0, 0.9);
                    color: #2a1600;
                    padding: 4px 8px;
                    font-size: 11px;
                    border-radius: 4px;
                    white-space: nowrap;
                    pointer-events: none;
                    font-weight: 600;
                `;
                puzzleEl.appendChild(label);

                puzzleEl.addEventListener('mousedown', startDragItem);

                // ‚úÖ Adicionar resize handles (v√©rtices) quando puzzle est√° selecionado
                if (isPuzzleSelected) {
                    const handles = ['nw', 'ne', 'sw', 'se'];
                    handles.forEach(handle => {
                        const handleEl = document.createElement('div');
                        handleEl.className = 'resize-handle';
                        handleEl.dataset.direction = handle;
                        handleEl.style.cssText = `
                            position: absolute;
                            width: 12px;
                            height: 12px;
                            background: #f0a500;
                            border: 2px solid white;
                            border-radius: 50%;
                            cursor: ${handle}-resize;
                            z-index: 1000;
                            pointer-events: auto;
                        `;
                        if (handle.includes('n')) handleEl.style.top = '-6px';
                        if (handle.includes('s')) handleEl.style.bottom = '-6px';
                        if (handle.includes('w')) handleEl.style.left = '-6px';
                        if (handle.includes('e')) handleEl.style.right = '-6px';

                        handleEl.addEventListener('mousedown', startResizeItem);
                        puzzleEl.appendChild(handleEl);
                    });
                }

                container.appendChild(puzzleEl);

                // Renderizar caixinhas de d√≠gitos para cadeado de 5 d√≠gitos
                if (location.puzzle.type === 'padlock_5digit') {
                    renderPadlockDigitBoxes(location.puzzle, container);
                }

                // Renderizar moldes para Conecta Blocos
                if (location.puzzle.type === 'shape_match') {
                    renderShapeMatchMoldBoxes(location.puzzle, container);
                }
            }

            location.items.forEach((item, index) => {
                ensureItemDefaults(item);

                const isSelected = selectedVisualType === 'item' && selectedItemIndex === index;

                const transforms = [
                    'translate(-50%, -50%)',
                    `rotateZ(${item.transform.rotation || 0}deg)`,
                    `rotateX(${item.transform.rotateX || 0}deg)`,
                    `rotateY(${item.transform.rotateY || 0}deg)`,
                    `scaleX(${(item.transform.scaleX || 1) * (item.transform.flipX ? -1 : 1)})`,
                    `scaleY(${(item.transform.scaleY || 1) * (item.transform.flipY ? -1 : 1)})`,
                    `skewX(${item.transform.skewX || 0}deg)`,
                    `skewY(${item.transform.skewY || 0}deg)`
                ];

                const shadowBlur = item.transform.shadowBlur || 0;
                const shadowX = item.transform.shadowOffsetX || 0;
                const shadowY = item.transform.shadowOffsetY || 0;
                const filterString = shadowBlur > 0
                    ? `drop-shadow(${shadowX}px ${shadowY}px ${shadowBlur}px rgba(0,0,0,0.5))`
                    : 'none';

                const itemEl = document.createElement('div');
                itemEl.dataset.visualType = 'item';
                itemEl.dataset.itemIndex = index;
                itemEl.style.cssText = `
                    position: absolute;
                    left: ${item.position.x}%;
                    top: ${item.position.y}%;
                    width: ${item.size.width}px;
                    height: ${item.size.height}px;
                    transform: ${transforms.join(' ')};
                    cursor: move;
                    pointer-events: auto;
                    z-index: 100;
                    border-radius: 4px;
                    opacity: ${item.transform.opacity || 1};
                    filter: ${filterString};
                    ${isSelected ? 'box-shadow: 0 0 0 3px #667eea;' : ''}
                `;

                // ‚úÖ Wrapper para conte√∫do visual (n√£o interfere com handles)
                const contentWrapper = document.createElement('div');
                contentWrapper.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    overflow: hidden;
                    z-index: 1;
                `;
                itemEl.appendChild(contentWrapper);

                // ‚úÖ Detectar tipo de anima√ß√£o
                if (item.image && item.image.includes('_atlas.png')) {
                    // TEXTURE ATLAS: Carregar PNG + JSON
                    const atlasImg = new Image();
                    const jsonPath = item.image.replace('.png', '.json');

                    // Carregar JSON primeiro
                    fetch(jsonPath)
                        .then(r => r.json())
                        .then(atlasData => {
                            atlasImg.onload = () => {
                                // Criar canvas
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                canvas.style.cssText = `
                                    width: 100%;
                                    height: 100%;
                                    display: block;
                                `;
                                contentWrapper.appendChild(canvas);

                                // Pegar frames do JSON
                                const frameKeys = Object.keys(atlasData.frames);
                                const firstFrame = atlasData.frames[frameKeys[0]];

                                canvas.width = firstFrame.frame.w;
                                canvas.height = firstFrame.frame.h;

                                let currentFrameIndex = 0;
                                let lastFrameTime = 0;
                                const frameRate = item.spritesheetFrameRate || 10;
                                const frameDuration = 1000 / frameRate;

                                function animate(timestamp) {
                                    if (!lastFrameTime) lastFrameTime = timestamp;
                                    const elapsed = timestamp - lastFrameTime;

                                    if (elapsed >= frameDuration) {
                                        const frameKey = frameKeys[currentFrameIndex];
                                        const frameData = atlasData.frames[frameKey];
                                        const frame = frameData.frame;

                                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                                        ctx.drawImage(
                                            atlasImg,
                                            frame.x, frame.y, frame.w, frame.h,
                                            0, 0, frame.w, frame.h
                                        );

                                        currentFrameIndex = (currentFrameIndex + 1) % frameKeys.length;
                                        lastFrameTime = timestamp;
                                    }

                                    requestAnimationFrame(animate);
                                }

                                requestAnimationFrame(animate);
                            };

                            atlasImg.src = item.image;
                        })
                        .catch(err => {
                            console.error('Erro ao carregar atlas JSON:', err);
                            // Fallback para imagem est√°tica
                            const img = document.createElement('img');
                            img.src = item.image;
                            img.style.cssText = 'width: 100%; height: 100%; object-fit: contain;';
                            contentWrapper.appendChild(img);
                        });

                } else if (item.image && item.image.includes('_spritesheet.png')) {
                    // SPRITESHEET: Carregar imagem primeiro, depois criar canvas
                    const spriteImg = new Image();
                    spriteImg.onload = () => {
                        // Criar canvas AP√ìS imagem carregar
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.style.cssText = `
                            width: 100%;
                            height: 100%;
                            display: block;
                        `;
                        contentWrapper.appendChild(canvas);

                        // Configurar anima√ß√£o
                        const frameWidth = item.spritesheetFrameWidth || 249;
                        const frameHeight = item.spritesheetFrameHeight || 341;
                        const frameCount = Math.floor(spriteImg.width / frameWidth);
                        const frameRate = item.spritesheetFrameRate || 10;

                        canvas.width = frameWidth;
                        canvas.height = frameHeight;

                        let currentFrame = 0;
                        let lastFrameTime = 0;
                        const frameDuration = 1000 / frameRate;

                        function animate(timestamp) {
                            if (!lastFrameTime) lastFrameTime = timestamp;
                            const elapsed = timestamp - lastFrameTime;

                            if (elapsed >= frameDuration) {
                                ctx.clearRect(0, 0, frameWidth, frameHeight);
                                ctx.drawImage(
                                    spriteImg,
                                    currentFrame * frameWidth, 0, frameWidth, frameHeight,
                                    0, 0, frameWidth, frameHeight
                                );

                                currentFrame = (currentFrame + 1) % frameCount;
                                lastFrameTime = timestamp;
                            }

                            requestAnimationFrame(animate);
                        }

                        requestAnimationFrame(animate);
                    };
                    spriteImg.src = item.image;
                } else if (item.image) {
                    // GIF ou imagem est√°tica: usar <img> tag
                    const img = document.createElement('img');
                    img.src = item.image;
                    img.style.cssText = `
                        width: 100%;
                        height: 100%;
                        object-fit: contain;
                        display: block;
                    `;
                    contentWrapper.appendChild(img);
                } else {
                    // Fallback: sem imagem
                    itemEl.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    itemEl.style.border = '3px dashed white';
                }

                const label = document.createElement('div');
                label.textContent = item.name;
                label.style.cssText = `
                    position: absolute;
                    bottom: -25px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 4px 8px;
                    font-size: 11px;
                    border-radius: 4px;
                    white-space: nowrap;
                    pointer-events: none;
                    z-index: 2;
                `;

                itemEl.appendChild(label);
                itemEl.addEventListener('mousedown', startDragItem);

                // ‚úÖ Adicionar resize handles (v√©rtices) quando item est√° selecionado
                if (isSelected) {
                    const handles = ['nw', 'ne', 'sw', 'se'];
                    handles.forEach(handle => {
                        const handleEl = document.createElement('div');
                        handleEl.className = 'resize-handle';
                        handleEl.dataset.direction = handle;
                        handleEl.style.cssText = `
                            position: absolute;
                            width: 12px;
                            height: 12px;
                            background: #667eea;
                            border: 2px solid white;
                            border-radius: 50%;
                            cursor: ${handle}-resize;
                            z-index: 1000;
                            pointer-events: auto;
                        `;
                        if (handle.includes('n')) handleEl.style.top = '-6px';
                        if (handle.includes('s')) handleEl.style.bottom = '-6px';
                        if (handle.includes('w')) handleEl.style.left = '-6px';
                        if (handle.includes('e')) handleEl.style.right = '-6px';

                        handleEl.addEventListener('mousedown', startResizeItem);
                        itemEl.appendChild(handleEl);
                    });
                }

                container.appendChild(itemEl);
            });

            highlightSelectedVisual();
        }

        // Render transform controls panel
        function renderTransformControls() {
            const panel = document.getElementById('transform-controls');

            if (!currentLocationId) {
                panel.innerHTML = '<div style="color: #999; text-align: center; padding: 20px; font-size: 14px;">Selecione um local para editar</div>';
                return;
            }

            const visual = getSelectedVisual();
            if (!visual) {
                panel.innerHTML = '<div style="color: #999; text-align: center; padding: 20px; font-size: 14px;">Selecione um item, enigma ou parede para editar</div>';
                return;
            }

            // Special handling for digits
            if (visual.type === 'digit') {
                const digitIndex = selectedItemIndex;
                const location = gameLocations[currentLocationId];
                const pos = location.puzzle.digitPositions[digitIndex];

                panel.innerHTML = `
                    <div style="margin-bottom: 15px;">
                        <strong style="display: block; margin-bottom: 8px;">üî¢ D√≠gito ${digitIndex + 1}</strong>
                        <div style="font-size: 11px; color: #666; margin-bottom: 10px;">Posicione sobre a imagem do cadeado</div>

                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 13px; font-weight: 600;">Posi√ß√£o (%)</label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                <div>
                                    <label style="font-size: 11px; color: #666;">X</label>
                                    <input type="number" value="${pos.x.toFixed(1)}" step="0.1"
                                           style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                                           onchange="updateDigitPosition(${digitIndex}, 'x', parseFloat(this.value))">
                                </div>
                                <div>
                                    <label style="font-size: 11px; color: #666;">Y</label>
                                    <input type="number" value="${pos.y.toFixed(1)}" step="0.1"
                                           style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                                           onchange="updateDigitPosition(${digitIndex}, 'y', parseFloat(this.value))">
                                </div>
                            </div>
                        </div>

                        <div style="background: #f0f8ff; padding: 12px; border-radius: 6px; border-left: 4px solid #00bfff;">
                            <div style="font-size: 12px; color: #333; margin-bottom: 5px; font-weight: 600;">üí° Dica</div>
                            <div style="font-size: 11px; color: #555; line-height: 1.4;">
                                Arraste o d√≠gito para a posi√ß√£o correta sobre a imagem do cadeado. As 5 caixinhas aparecer√£o no jogo exatamente nas posi√ß√µes que voc√™ definir aqui.
                            </div>
                        </div>
                    </div>
                `;
                return;
            }

            // Special handling for walls
            if (visual.type === 'wall') {
                const wall = visual.data;
                const previewHtml = wall.image
                    ? `<img src="${wall.image}" style="max-width: 100%; max-height: 100px; image-rendering: crisp-edges; border: 2px solid #ddd; border-radius: 4px;">`
                    : '<div style="color: #999; font-size: 12px; padding: 20px; background: #f5f5f5; border-radius: 4px; text-align: center;">Sem imagem atribu√≠da</div>';

                panel.innerHTML = `
                    <div style="margin-bottom: 15px;">
                        <strong style="display: block; margin-bottom: 8px;">Parede: ${wall.id}</strong>
                        <div style="font-size: 11px; color: #666; margin-bottom: 10px;">Item necess√°rio: ${wall.requiredItem || 'Nenhum'}</div>

                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 13px; font-weight: 600;">Imagem da Parede</label>
                            <input type="file"
                                   id="wall-image-transform"
                                   accept="image/png"
                                   style="display: none;"
                                   onchange="handleWallImageUpload(selectedWallIndex, event)">
                            <button class="btn btn-secondary btn-small"
                                    style="width: 100%; margin-bottom: 8px;"
                                    onclick="document.getElementById('wall-image-transform').click()">
                                ${wall.image ? '‚úì Alterar PNG' : 'üìÅ Upload PNG'}
                            </button>
                            ${wall.image ? `
                                <button class="btn btn-primary btn-small"
                                        style="width: 100%; margin-bottom: 8px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);"
                                        onclick="autoPositionWall(selectedWallIndex)">
                                    ü§ñ Auto-Posicionar IA
                                </button>
                            ` : ''}
                            ${previewHtml}
                            <input type="text" value="${wall.image || ''}"
                                   placeholder="ou cole o caminho da imagem"
                                   style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; margin-top: 8px; font-size: 12px;"
                                   onchange="updateWallProperty('image', this.value)">
                        </div>

                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 13px; font-weight: 600;">Posi√ß√£o (%)</label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                <div>
                                    <label style="font-size: 11px; color: #666;">X</label>
                                    <input type="number" value="${wall.x}" step="0.1"
                                           style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                                           onchange="updateWallProperty('x', parseFloat(this.value))">
                                </div>
                                <div>
                                    <label style="font-size: 11px; color: #666;">Y</label>
                                    <input type="number" value="${wall.y}" step="0.1"
                                           style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                                           onchange="updateWallProperty('y', parseFloat(this.value))">
                                </div>
                            </div>
                        </div>

                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 13px; font-weight: 600;">Tamanho (%)</label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                <div>
                                    <label style="font-size: 11px; color: #666;">Largura</label>
                                    <input type="number" value="${wall.width}" step="0.1"
                                           style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                                           onchange="updateWallProperty('width', parseFloat(this.value))">
                                </div>
                                <div>
                                    <label style="font-size: 11px; color: #666;">Altura</label>
                                    <input type="number" value="${wall.height}" step="0.1"
                                           style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                                           onchange="updateWallProperty('height', parseFloat(this.value))">
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                return;
            }

            // Hotspot controls
            if (visual.type === 'hotspot') {
                const hotspot = visual.data;

                panel.innerHTML = `
                    <div style="margin-bottom: 15px;">
                        <strong style="display: block; margin-bottom: 8px;">üéØ Hotspot: ${hotspot.name}</strong>
                        <div style="font-size: 11px; color: #666; margin-bottom: 10px;">Destino: ${hotspot.target || 'Nenhum'}</div>

                        <div style="padding: 15px; background: #f0f8ff; border-radius: 6px; border-left: 4px solid #00bfff;">
                            <div style="font-size: 12px; color: #333; margin-bottom: 5px; font-weight: 600;">üí° Ajustar forma</div>
                            <div style="font-size: 11px; color: #555; line-height: 1.4;">
                                Arraste os 4 cantos (bolinhas laranjas) do hotspot na imagem para ajustar a √°rea clic√°vel a qualquer formato (portas em perspectiva, etc).
                            </div>
                        </div>
                    </div>
                `;
                return;
            }

            const data = visual.data;
            const transform = data.transform || cloneDefaultTransform();
            data.transform = transform;
            const size = data.size || { width: 80, height: 80 };
            data.size = size;

            const title = visual.type === 'item'
                ? (data.name || 'Item sem nome')
                : `Enigma ${visual.puzzle?.id || ''}`;

            const previewImage = visual.type === 'item' ? (data.image || '') : (data.beforeImage || '');
            const afterImage = visual.type === 'puzzle' ? data.afterImage : null;

            const previewHtml = previewImage
                ? `<img src="${previewImage}" style="max-width: 100%; max-height: 100px; image-rendering: crisp-edges;">`
                : '<div style="color: #999; font-size: 12px;">Sem imagem atribu√≠da</div>';

            const afterHtml = afterImage
                ? `<div style="margin-top: 10px;">
                        <label style="font-size: 11px; color: #805400;">Ap√≥s resolver</label>
                        <img src="${afterImage}" style="max-width: 100%; max-height: 80px; image-rendering: crisp-edges; opacity: 0.85;">
                   </div>`
                : '';

            panel.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <strong style="display: block; margin-bottom: 8px;">${title}</strong>
                    ${previewHtml}
                    ${afterHtml}
                    ${visual.type === 'puzzle' ? '<div style="margin-top:6px; font-size: 11px; color: #805400;">Este visual representa o estado antes de resolver o enigma.</div>' : ''}
                </div>

                <button class="btn btn-primary"
                        style="width: 100%; margin-bottom: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);"
                        onclick="renderPositionedItems()">
                    üìê Redimensionar
                </button>

                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 13px; font-weight: 600;">Tamanho</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div>
                            <label style="font-size: 11px; color: #666;">Largura (px)</label>
                            <input type="number" id="item-width" value="${size.width || 80}"
                                   style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                                   onchange="updateItemSize()">
                        </div>
                        <div>
                            <label style="font-size: 11px; color: #666;">Altura (px)</label>
                            <input type="number" id="item-height" value="${size.height || 80}"
                                   style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                                   onchange="updateItemSize()">
                        </div>
                    </div>
                </div>

                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 13px; font-weight: 600;">Rota√ß√£o Z (plano)</label>
                    <input type="range" id="item-rotation" min="-180" max="180" value="${transform.rotation || 0}"
                           style="width: 100%;"
                           oninput="updateItemTransform()">
                    <div style="text-align: center; font-size: 12px; color: #666; margin-top: 4px;">
                        <span id="rotation-value">${transform.rotation || 0}¬∞</span>
                    </div>
                </div>

                <div style="margin-bottom: 15px; padding: 10px; background: #f0f0ff; border-radius: 6px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 13px; font-weight: 600; color: #667eea;">üéØ Perspectiva 3D</label>

                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 11px; color: #666;">Inclinar X (horizontal)</label>
                        <input type="range" id="item-rotate-x" min="-90" max="90" value="${transform.rotateX || 0}"
                               style="width: 100%;"
                               oninput="updateItemTransform()">
                        <div style="text-align: center; font-size: 11px;" id="rotate-x-value">${transform.rotateX || 0}¬∞</div>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 11px; color: #666;">Inclinar Y (vertical)</label>
                        <input type="range" id="item-rotate-y" min="-90" max="90" value="${transform.rotateY || 0}"
                               style="width: 100%;"
                               oninput="updateItemTransform()">
                        <div style="text-align: center; font-size: 11px;" id="rotate-y-value">${transform.rotateY || 0}¬∞</div>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 11px; color: #666;">Distorcer X (horizontal)</label>
                        <input type="range" id="item-skew-x" min="-60" max="60" value="${transform.skewX || 0}"
                               style="width: 100%;"
                               oninput="updateItemTransform()">
                        <div style="text-align: center; font-size: 11px;" id="skew-x-value">${transform.skewX || 0}¬∞</div>
                    </div>

                    <div>
                        <label style="font-size: 11px; color: #666;">Distorcer Y (vertical)</label>
                        <input type="range" id="item-skew-y" min="-60" max="60" value="${transform.skewY || 0}"
                               style="width: 100%;"
                               oninput="updateItemTransform()">
                        <div style="text-align: center; font-size: 11px;" id="skew-y-value">${transform.skewY || 0}¬∞</div>
                    </div>
                </div>

                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 13px; font-weight: 600;">Escala</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div>
                            <label style="font-size: 11px; color: #666;">Escala X</label>
                            <input type="range" id="item-scale-x" min="0.1" max="3" step="0.1" value="${transform.scaleX || 1}"
                                   style="width: 100%;"
                                   oninput="updateItemTransform()">
                            <div style="text-align: center; font-size: 11px;" id="scale-x-value">${transform.scaleX || 1}x</div>
                        </div>
                        <div>
                            <label style="font-size: 11px; color: #666;">Escala Y</label>
                            <input type="range" id="item-scale-y" min="0.1" max="3" step="0.1" value="${transform.scaleY || 1}"
                                   style="width: 100%;"
                                   oninput="updateItemTransform()">
                            <div style="text-align: center; font-size: 11px;" id="scale-y-value">${transform.scaleY || 1}x</div>
                        </div>
                    </div>
                </div>

                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 13px; font-weight: 600;">Espelhar</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button onclick="toggleFlipX()" class="btn btn-secondary btn-small" style="width: 100%;">
                            ${transform.flipX ? '‚ÜîÔ∏è Desfazer X' : '‚ÜîÔ∏è Flip X'}
                        </button>
                        <button onclick="toggleFlipY()" class="btn btn-secondary btn-small" style="width: 100%;">
                            ${transform.flipY ? '‚ÜïÔ∏è Desfazer Y' : '‚ÜïÔ∏è Flip Y'}
                        </button>
                    </div>
                </div>

                <div style="margin-bottom: 15px; padding: 10px; background: #f0fff0; border-radius: 6px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 13px; font-weight: 600; color: #28a745;">üíß Transpar√™ncia & Sombra</label>

                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 11px; color: #666;">Opacidade</label>
                        <input type="range" id="item-opacity" min="0" max="1" step="0.1" value="${typeof transform.opacity === 'number' ? transform.opacity : 1}"
                               style="width: 100%;"
                               oninput="updateItemEffects()">
                        <div style="text-align: center; font-size: 11px;" id="opacity-value">${Math.round((typeof transform.opacity === 'number' ? transform.opacity : 1) * 100)}%</div>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 11px; color: #666;">Desfoque da Sombra</label>
                        <input type="range" id="item-shadow-blur" min="0" max="30" step="1" value="${transform.shadowBlur || 0}"
                               style="width: 100%;"
                               oninput="updateItemEffects()">
                        <div style="text-align: center; font-size: 11px;" id="shadow-blur-value">${transform.shadowBlur || 0}px</div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div>
                            <label style="font-size: 11px; color: #666;">Sombra X</label>
                            <input type="range" id="item-shadow-x" min="-20" max="20" step="1" value="${transform.shadowOffsetX || 0}"
                                   style="width: 100%;"
                                   oninput="updateItemEffects()">
                            <div style="text-align: center; font-size: 11px;" id="shadow-x-value">${transform.shadowOffsetX || 0}px</div>
                        </div>
                        <div>
                            <label style="font-size: 11px; color: #666;">Sombra Y</label>
                            <input type="range" id="item-shadow-y" min="-20" max="20" step="1" value="${transform.shadowOffsetY || 0}"
                                   style="width: 100%;"
                                   oninput="updateItemEffects()">
                            <div style="text-align: center; font-size: 11px;" id="shadow-y-value">${transform.shadowOffsetY || 0}px</div>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #ddd;">
                    <button onclick="resetTransforms()" class="btn btn-danger btn-small" style="width: 100%;">
                        üîÑ Resetar Transforma√ß√µes
                    </button>
                </div>
            `;
        }

        function updateWallProperty(prop, value) {
            if (!currentLocationId || selectedWallIndex === null) return;
            const location = gameLocations[currentLocationId];
            if (location.destructibleWalls && location.destructibleWalls[selectedWallIndex]) {
                location.destructibleWalls[selectedWallIndex][prop] = value;
                autoSave();
                renderPositionedWalls();
                renderDestructibleWallsList();
                renderTransformControls(); // Atualizar preview da imagem
                renderVisualWallsList(); // Atualizar lista visual
            }
        }

        function updateDigitPosition(digitIndex, prop, value) {
            if (!currentLocationId) return;
            const location = gameLocations[currentLocationId];
            if (location.puzzle && location.puzzle.digitPositions && location.puzzle.digitPositions[digitIndex]) {
                location.puzzle.digitPositions[digitIndex][prop] = value;
                autoSave();
                renderPositionedItems();
                renderTransformControls();
            }
        }

        function updateItemSize() {
            if (!currentLocationId) return;
            const visual = getSelectedVisual();
            if (!visual) return;

            const width = parseInt(document.getElementById('item-width').value);
            const height = parseInt(document.getElementById('item-height').value);

            if (!Number.isNaN(width)) visual.data.size.width = width;
            if (!Number.isNaN(height)) visual.data.size.height = height;

            renderPositionedItems();
        }

        function updateItemTransform() {
            if (!currentLocationId) return;
            const visual = getSelectedVisual();
            if (!visual) return;

            const transform = visual.data.transform || cloneDefaultTransform();
            visual.data.transform = transform;

            const rotation = parseFloat(document.getElementById('item-rotation').value);
            const scaleX = parseFloat(document.getElementById('item-scale-x').value);
            const scaleY = parseFloat(document.getElementById('item-scale-y').value);
            const rotateX = parseFloat(document.getElementById('item-rotate-x').value);
            const rotateY = parseFloat(document.getElementById('item-rotate-y').value);
            const skewX = parseFloat(document.getElementById('item-skew-x').value);
            const skewY = parseFloat(document.getElementById('item-skew-y').value);

            if (!Number.isNaN(rotation)) transform.rotation = rotation;
            if (!Number.isNaN(scaleX)) transform.scaleX = scaleX;
            if (!Number.isNaN(scaleY)) transform.scaleY = scaleY;
            if (!Number.isNaN(rotateX)) transform.rotateX = rotateX;
            if (!Number.isNaN(rotateY)) transform.rotateY = rotateY;
            if (!Number.isNaN(skewX)) transform.skewX = skewX;
            if (!Number.isNaN(skewY)) transform.skewY = skewY;

            document.getElementById('rotation-value').textContent = (transform.rotation || 0) + '¬∞';
            document.getElementById('scale-x-value').textContent = (transform.scaleX || 1) + 'x';
            document.getElementById('scale-y-value').textContent = (transform.scaleY || 1) + 'x';
            document.getElementById('rotate-x-value').textContent = (transform.rotateX || 0) + '¬∞';
            document.getElementById('rotate-y-value').textContent = (transform.rotateY || 0) + '¬∞';
            document.getElementById('skew-x-value').textContent = (transform.skewX || 0) + '¬∞';
            document.getElementById('skew-y-value').textContent = (transform.skewY || 0) + '¬∞';

            renderPositionedItems();
        }

        function updateItemEffects() {
            if (!currentLocationId) return;
            const visual = getSelectedVisual();
            if (!visual) return;

            const transform = visual.data.transform || cloneDefaultTransform();
            visual.data.transform = transform;

            const opacity = parseFloat(document.getElementById('item-opacity').value);
            const shadowBlur = parseInt(document.getElementById('item-shadow-blur').value);
            const shadowX = parseInt(document.getElementById('item-shadow-x').value);
            const shadowY = parseInt(document.getElementById('item-shadow-y').value);

            if (!Number.isNaN(opacity)) transform.opacity = opacity;
            if (!Number.isNaN(shadowBlur)) transform.shadowBlur = shadowBlur;
            if (!Number.isNaN(shadowX)) transform.shadowOffsetX = shadowX;
            if (!Number.isNaN(shadowY)) transform.shadowOffsetY = shadowY;

            document.getElementById('opacity-value').textContent = Math.round((transform.opacity || 1) * 100) + '%';
            document.getElementById('shadow-blur-value').textContent = (transform.shadowBlur || 0) + 'px';
            document.getElementById('shadow-x-value').textContent = (transform.shadowOffsetX || 0) + 'px';
            document.getElementById('shadow-y-value').textContent = (transform.shadowOffsetY || 0) + 'px';

            renderPositionedItems();
        }

        function toggleFlipX() {
            if (!currentLocationId) return;
            const visual = getSelectedVisual();
            if (!visual) return;

            const transform = visual.data.transform || cloneDefaultTransform();
            transform.flipX = !transform.flipX;
            visual.data.transform = transform;

            autoSave();
            renderTransformControls();
            renderPositionedItems();
        }

        function toggleFlipY() {
            if (!currentLocationId) return;
            const visual = getSelectedVisual();
            if (!visual) return;

            const transform = visual.data.transform || cloneDefaultTransform();
            transform.flipY = !transform.flipY;
            visual.data.transform = transform;

            autoSave();
            renderTransformControls();
            renderPositionedItems();
        }

        function resetTransforms() {
            if (!currentLocationId) return;
            const visual = getSelectedVisual();
            if (!visual) return;

            visual.data.transform = cloneDefaultTransform();

            autoSave();
            renderTransformControls();
            renderPositionedItems();
        }

        function startResizeItem(e) {
            resizingItem = e.target.parentElement;
            resizeDirection = e.target.dataset.direction;

            const visualType = resizingItem?.dataset.visualType || 'item';
            if (visualType === 'item') {
                const index = parseInt(resizingItem.dataset.itemIndex);
                if (!Number.isNaN(index)) {
                    selectItem(index);
                }
            } else if (visualType === 'puzzle') {
                selectPuzzleVisual();
            }

            document.addEventListener('mousemove', resizeItem);
            document.addEventListener('mouseup', stopResizeItem);

            e.stopPropagation();
            e.preventDefault();
        }

        function resizeItem(e) {
            if (!resizingItem || !currentLocationId) return;

            const visual = getSelectedVisual();
            if (!visual) return;

            const container = document.getElementById('visual-items-container');
            const rect = container.getBoundingClientRect();

            const centerX = (parseFloat(resizingItem.style.left) / 100) * rect.width;
            const centerY = (parseFloat(resizingItem.style.top) / 100) * rect.height;

            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const visualType = resizingItem.dataset.visualType;

            if (visualType === 'puzzle') {
                // Para puzzle, usar SCALE em vez de SIZE (manter tamanho original da imagem)
                const img = resizingItem.querySelector('img');
                if (!img) return;

                // Pegar tamanho natural da imagem
                const naturalWidth = img.naturalWidth;
                const naturalHeight = img.naturalHeight;

                if (!naturalWidth || !naturalHeight) return;

                // Calcular nova largura/altura desejada
                const newWidth = Math.abs(mouseX - centerX) * 2;
                const newHeight = Math.abs(mouseY - centerY) * 2;

                // Calcular scale baseado no tamanho natural
                const scaleX = Math.max(0.1, newWidth / naturalWidth);
                const scaleY = Math.max(0.1, newHeight / naturalHeight);

                // Atualizar transform (n√£o size!)
                visual.data.transform.scaleX = scaleX;
                visual.data.transform.scaleY = scaleY;

                // Atualizar transform no DOM diretamente (sem re-renderizar)
                const puzzleVisual = visual.data;
                const transforms = [
                    'translate(-50%, -50%)',
                    `rotateZ(${puzzleVisual.transform.rotation || 0}deg)`,
                    `rotateX(${puzzleVisual.transform.rotateX || 0}deg)`,
                    `rotateY(${puzzleVisual.transform.rotateY || 0}deg)`,
                    `scaleX(${(puzzleVisual.transform.scaleX || 1) * (puzzleVisual.transform.flipX ? -1 : 1)})`,
                    `scaleY(${(puzzleVisual.transform.scaleY || 1) * (puzzleVisual.transform.flipY ? -1 : 1)})`,
                    `skewX(${puzzleVisual.transform.skewX || 0}deg)`,
                    `skewY(${puzzleVisual.transform.skewY || 0}deg)`
                ];
                resizingItem.style.transform = transforms.join(' ');
            } else {
                // Para items, usar SIZE (comportamento original)
                const newWidth = Math.abs(mouseX - centerX) * 2;
                const newHeight = Math.abs(mouseY - centerY) * 2;

                visual.data.size.width = Math.max(20, Math.round(newWidth));
                visual.data.size.height = Math.max(20, Math.round(newHeight));

                resizingItem.style.width = visual.data.size.width + 'px';
                resizingItem.style.height = visual.data.size.height + 'px';
            }
        }

        function stopResizeItem() {
            if (resizingItem) {
                renderTransformControls();
                autoSave();
            }

            resizingItem = null;
            resizeDirection = null;
            document.removeEventListener('mousemove', resizeItem);
            document.removeEventListener('mouseup', stopResizeItem);
        }

        function startDragItem(e) {
            draggedItem = this;
            const visualType = draggedItem.dataset.visualType || 'item';

            if (visualType === 'item') {
                const index = parseInt(draggedItem.dataset.itemIndex);
                if (!Number.isNaN(index)) {
                    selectItem(index);
                }
            } else if (visualType === 'puzzle') {
                selectPuzzleVisual();
            } else if (visualType === 'digit') {
                const index = parseInt(draggedItem.dataset.digitIndex);
                if (!Number.isNaN(index)) {
                    selectDigit(index);
                }
            } else if (visualType === 'mold') {
                const index = parseInt(draggedItem.dataset.moldIndex);
                if (!Number.isNaN(index)) {
                    selectMold(index);
                }
            }

            const container = document.getElementById('visual-items-container');
            const rect = container.getBoundingClientRect();

            const currentLeft = parseFloat(draggedItem.style.left);
            const currentTop = parseFloat(draggedItem.style.top);

            const currentLeftPx = (currentLeft / 100) * rect.width;
            const currentTopPx = (currentTop / 100) * rect.height;

            dragOffsetX = e.clientX - rect.left - currentLeftPx;
            dragOffsetY = e.clientY - rect.top - currentTopPx;

            document.addEventListener('mousemove', dragItem);
            document.addEventListener('mouseup', stopDragItem);

            e.preventDefault();
            e.stopPropagation();
        }

        function selectItem(itemIndex) {
            selectedVisualType = 'item';
            selectedItemIndex = itemIndex;
            renderTransformControls();
            highlightSelectedVisual();
        }

        function selectPuzzleVisual() {
            selectedVisualType = 'puzzle';
            selectedItemIndex = null;
            renderTransformControls();
            highlightSelectedVisual();
        }

        function selectDigit(digitIndex) {
            selectedVisualType = 'digit';
            selectedItemIndex = digitIndex;
            renderTransformControls();
            highlightSelectedVisual();
        }

        function selectMold(moldIndex) {
            selectedVisualType = 'mold';
            selectedItemIndex = moldIndex;
            renderTransformControls();
            highlightSelectedVisual();
        }

        function dragItem(e) {
            if (!draggedItem) return;

            const container = document.getElementById('visual-items-container');
            const rect = container.getBoundingClientRect();

            let x = ((e.clientX - rect.left - dragOffsetX) / rect.width) * 100;
            let y = ((e.clientY - rect.top - dragOffsetY) / rect.height) * 100;

            x = Math.max(0, Math.min(100, x));
            y = Math.max(0, Math.min(100, y));

            draggedItem.style.left = x + '%';
            draggedItem.style.top = y + '%';
        }

        function stopDragItem(e) {
            if (!draggedItem || !currentLocationId) return;

            const visualType = draggedItem.dataset.visualType || 'item';
            const location = gameLocations[currentLocationId];
            const newX = parseFloat(draggedItem.style.left);
            const newY = parseFloat(draggedItem.style.top);

            if (visualType === 'item') {
                const index = parseInt(draggedItem.dataset.itemIndex);
                if (!Number.isNaN(index) && location.items && location.items[index]) {
                    ensureItemDefaults(location.items[index]);
                    location.items[index].position = { x: newX, y: newY };
                }
            } else if (visualType === 'puzzle' && location.puzzle) {
                ensurePuzzleDefaults(location.puzzle);
                location.puzzle.visual.position = { x: newX, y: newY };
            } else if (visualType === 'digit' && location.puzzle) {
                const index = parseInt(draggedItem.dataset.digitIndex);
                if (!Number.isNaN(index) && location.puzzle.digitPositions && location.puzzle.digitPositions[index]) {
                    location.puzzle.digitPositions[index] = { x: newX, y: newY };
                }
            } else if (visualType === 'mold' && location.puzzle) {
                const index = parseInt(draggedItem.dataset.moldIndex);

                if (!Number.isNaN(index) && location.puzzle.molds && location.puzzle.molds[index]) {
                    // Salvar como porcentagem (igual aos d√≠gitos do cadeado)
                    location.puzzle.molds[index].x = newX;
                    location.puzzle.molds[index].y = newY;

                    // Atualizar tamb√©m o currentMolds para o editor de moldes
                    if (currentMolds && currentMolds[index]) {
                        currentMolds[index].x = newX;
                        currentMolds[index].y = newY;
                    }
                }
            }

            autoSave();
            renderVisualItemsList();

            draggedItem = null;
            document.removeEventListener('mousemove', dragItem);
            document.removeEventListener('mouseup', stopDragItem);
        }

        // ==================== HOTSPOTS VISUAIS ====================
        let isDrawingHotspot = false;
        let hotspotStartX = 0;
        let hotspotStartY = 0;
        let currentDrawingRect = null;

        function startDrawingHotspot() {
            if (!currentLocationId) {
                showToast('‚ö†Ô∏è Selecione um local primeiro', 'warning');
                return;
            }

            const visualImage = document.getElementById('visual-location-image');
            if (!visualImage.src || visualImage.style.display === 'none') {
                showToast('‚ö†Ô∏è Fa√ßa upload de uma imagem primeiro', 'warning');
                return;
            }

            isDrawingHotspot = true;
            showToast('‚úèÔ∏è Clique e arraste na imagem', 'info');
        }

        function renderVisualHotspotsList() {
            if (!currentLocationId) return;

            const location = gameLocations[currentLocationId];
            const list = document.getElementById('visual-hotspots-list');

            if (!location.hotspots || location.hotspots.length === 0) {
                list.innerHTML = '<div style="color: #999; font-size: 12px; text-align: center; padding: 10px;">Nenhum hotspot</div>';
                return;
            }

            list.innerHTML = '';
            location.hotspots.forEach((hotspot, index) => {
                if (hotspot.action === 'navigate' && hotspot.position) {
                    const hotspotEl = document.createElement('div');
                    hotspotEl.style.cssText = `
            background: #fff;
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 4px;
            border: 2px solid #28a745;
            font-size: 11px;
            cursor: pointer;
            `;
                    // ‚úÖ Emoji de seta baseado em arrowDirection
                const arrowEmoji = {
                    'up': '‚¨ÜÔ∏è',
                    'down': '‚¨áÔ∏è',
                    'left': '‚¨ÖÔ∏è',
                    'right': '‚û°Ô∏è'
                };
                const arrowDisplay = hotspot.arrowDirection ? arrowEmoji[hotspot.arrowDirection] || '' : '';

                // ‚úÖ Emoji de zoom baseado em zoomDirection
                const zoomEmoji = {
                    'in': 'üîç+',
                    'out': 'üîç-'
                };
                const zoomDisplay = hotspot.zoomDirection ? zoomEmoji[hotspot.zoomDirection] || '' : '';

                hotspotEl.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 4px;">üìç ${hotspot.name || 'Hotspot ' + (index + 1)} ${arrowDisplay} ${zoomDisplay}</div>
                        <div style="color: #666; font-size: 10px;">‚Üí ${hotspot.target || 'destino'}</div>
                        <div style="margin-top: 6px; display: flex; gap: 4px;">
                            <button onclick="editVisualHotspot(${index})" style="flex: 1; padding: 4px; font-size: 10px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">‚úèÔ∏è Editar</button>
                            <button onclick="deleteVisualHotspot(${index})" style="flex: 1; padding: 4px; font-size: 10px; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer;">üóëÔ∏è</button>
                        </div>
            `;
                    list.appendChild(hotspotEl);
                }
            });
        }

        // Render visual walls list
        function renderVisualWallsList() {
            if (!currentLocationId) return;

            const location = gameLocations[currentLocationId];
            const list = document.getElementById('visual-walls-list');

            if (!location.destructibleWalls || location.destructibleWalls.length === 0) {
                list.innerHTML = '<div style="color: #999; font-size: 12px; text-align: center; padding: 10px;">Nenhuma parede. Adicione paredes na aba "Paredes".</div>';
                return;
            }

            list.innerHTML = '';
            location.destructibleWalls.forEach((wall, index) => {
                const isSelected = selectedVisualType === 'wall' && selectedWallIndex === index;

                const wallEl = document.createElement('div');
                wallEl.style.cssText = `
                    background: ${isSelected ? '#fff6e5' : '#fff'};
                    padding: 10px;
                    margin-bottom: 8px;
                    border-radius: 6px;
                    border: 2px solid ${isSelected ? '#ff4444' : '#e0e0e0'};
                    cursor: pointer;
                    transition: all 0.2s;
                `;

                wallEl.innerHTML = `
                    <div style="font-weight: 600; margin-bottom: 8px;">üß± ${wall.id || 'Parede ' + (index + 1)}</div>
                    <input type="file"
                           id="wall-image-${index}"
                           accept="image/png"
                           style="display: none;"
                           onchange="handleWallImageUpload(${index}, event)">
                    <button class="btn btn-secondary btn-small"
                            style="width: 100%; margin-bottom: 5px; font-size: 11px;"
                            onclick="event.stopPropagation(); document.getElementById('wall-image-${index}').click()">
                        ${wall.image ? '‚úì Alterar PNG' : 'üìÅ Upload PNG'}
                    </button>
                    ${wall.image ? `
                        <div style="text-align: center; margin-top: 8px;">
                            <img src="${wall.image}" style="max-width: 100%; max-height: 60px; image-rendering: crisp-edges; border: 1px solid #ddd; border-radius: 4px;">
                            <div style="font-size: 10px; color: #999; margin-top: 5px;">
                                Pos: ${wall.x?.toFixed(1) || 0}%, ${wall.y?.toFixed(1) || 0}%
                            </div>
                        </div>
                    ` : '<div style="font-size: 11px; color: #999; margin-top: 5px; text-align: center;">Sem imagem</div>'}
                `;

                wallEl.addEventListener('click', () => {
                    selectWall(index);
                });

                list.appendChild(wallEl);
            });
        }

        let selectedHotspotIndex = null;
        let isDraggingHotspot = false;
        let isResizingHotspot = false;
        let hotspotDragOffset = { x: 0, y: 0 };
        let hotspotResizeHandle = null;

        function selectHotspot(index) {
            if (selectedHotspotIndex === index) return;
            selectedHotspotIndex = index;
            // Integrar com sistema de visual
            selectedVisualType = 'hotspot';
            selectedItemIndex = index;
            renderPositionedHotspots();
            renderTransformControls();
        }

        function deselectHotspots() {
            if (selectedHotspotIndex === null) return;
            selectedHotspotIndex = null;
            if (selectedVisualType === 'hotspot') {
                selectedVisualType = null;
                selectedItemIndex = null;
            }
            renderPositionedHotspots();
            renderTransformControls();
        }

        // Garante que hotspot tenha corners (converte de position se necess√°rio)
        function ensureHotspotCorners(hotspot) {
            if (!hotspot.corners && hotspot.position) {
                // Converter de ret√¢ngulo para 4 cantos
                const p = hotspot.position;
                hotspot.corners = [
                    { x: p.x, y: p.y },                           // top-left (nw - index 0)
                    { x: p.x + p.width, y: p.y },                 // top-right (ne - index 1)
                    { x: p.x + p.width, y: p.y + p.height },      // bottom-right (se - index 2)
                    { x: p.x, y: p.y + p.height }                 // bottom-left (sw - index 3)
                ];
            }
            return hotspot.corners;
        }

        function renderPositionedHotspots() {
            if (!currentLocationId) return;

            const location = gameLocations[currentLocationId];
            const container = document.getElementById('visual-hotspots-container');
            if (!container) return;

            const visualImage = document.getElementById('visual-location-image');
            const wrapper = document.getElementById('visual-wrapper');
            if (!visualImage || !visualImage.naturalWidth || !wrapper) {
                container.innerHTML = '';
                return;
            }

            const imgRect = visualImage.getBoundingClientRect();
            const wrapperRect = wrapper.getBoundingClientRect();
            const scale = imgRect.width / (visualImage.naturalWidth || imgRect.width);

            container.style.width = visualImage.naturalWidth + 'px';
            container.style.height = visualImage.naturalHeight + 'px';
            container.style.transform = `scale(${scale})`;
            container.style.transformOrigin = 'top left';
            container.style.left = (imgRect.left - wrapperRect.left) + 'px';
            container.style.top = (imgRect.top - wrapperRect.top) + 'px';

            container.innerHTML = '';

            if (!location.hotspots) {
                return;
            }


            location.hotspots.forEach((hotspot, index) => {

                // Aceita tanto 'navigate' quanto 'navigation'
                const isNavigationHotspot = (hotspot.action === 'navigate' || hotspot.action === 'navigation');
                if (!isNavigationHotspot || !hotspot.position) {
                    return;
                }

                // Garantir que tenha corners
                const corners = ensureHotspotCorners(hotspot);
                const isSelected = index === selectedHotspotIndex;

                // Calcular bounding box dos corners
                const xs = corners.map(c => c.x);
                const ys = corners.map(c => c.y);
                const minX = Math.min(...xs);
                const minY = Math.min(...ys);
                const maxX = Math.max(...xs);
                const maxY = Math.max(...ys);

                const hotspotEl = document.createElement('div');
                hotspotEl.dataset.hotspotIndex = index;
                hotspotEl.style.cssText = `
            position: absolute;
            left: ${minX}%;
            top: ${minY}%;
            width: ${maxX - minX}%;
            height: ${maxY - minY}%;
            cursor: move;
            pointer-events: auto;
            z-index: 50;
            `;

                // Criar SVG para desenhar o pol√≠gono
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;';
                svg.setAttribute('viewBox', `0 0 ${maxX - minX} ${maxY - minY}`);

                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const points = corners.map(c => `${c.x - minX},${c.y - minY}`).join(' ');
                polygon.setAttribute('points', points);
                polygon.setAttribute('fill', isSelected ? 'rgba(255, 68, 68, 0.3)' : 'rgba(40, 167, 69, 0.2)');
                polygon.setAttribute('stroke', isSelected ? '#ff4444' : '#28a745');
                polygon.setAttribute('stroke-width', '0.3');
                polygon.setAttribute('stroke-dasharray', isSelected ? '' : '1,0.5');
                svg.appendChild(polygon);
                hotspotEl.appendChild(svg);

                const label = document.createElement('div');
                label.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: ${isSelected ? 'rgba(204, 0, 0, 0.9)' : 'rgba(40, 167, 69, 0.9)'};
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            pointer-events: auto;
            white-space: nowrap;
            cursor: pointer;
            `;
                label.textContent = hotspot.name || 'Hotspot';
                label.title = 'Clique para navegar para ' + (hotspot.target || 'destino');

                // Clique no label navega para destino
                label.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    if (hotspot.target) {
                        autoSave();
                        selectLocation(hotspot.target);
                        showToast(`üìç Navegando para ${hotspot.target}`, 'info');
                    }
                });

                // Prevenir drag quando clicar no label
                label.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                });

                hotspotEl.appendChild(label);

                hotspotEl.addEventListener('mousedown', handleHotspotMouseDown);
                hotspotEl.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    editVisualHotspot(index);
                });

                if (isSelected) {
                    // Criar handle para cada canto do quadril√°tero
                    corners.forEach((corner, cornerIndex) => {
                        const handleEl = document.createElement('div');
                        handleEl.className = 'corner-handle';
                        handleEl.dataset.cornerIndex = cornerIndex;

                        // Posi√ß√£o do handle relativa ao bounding box
                        const handleX = ((corner.x - minX) / (maxX - minX)) * 100;
                        const handleY = ((corner.y - minY) / (maxY - minY)) * 100;

                        handleEl.style.cssText = `
            position: absolute;
            width: 16px;
            height: 16px;
            background: #ff8800;
            border: 2px solid white;
            border-radius: 50%;
            z-index: 100;
            cursor: move;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            left: ${handleX}%;
            top: ${handleY}%;
            transform: translate(-50%, -50%);
            `;

                        handleEl.addEventListener('mousedown', handleCornerMouseDown);
                        hotspotEl.appendChild(handleEl);
                    });
                }

                container.appendChild(hotspotEl);
            });
        }

        function handleHotspotMouseDown(e) {
            e.stopPropagation();
            const index = parseInt(e.target.closest('[data-hotspot-index]').dataset.hotspotIndex);
            selectHotspot(index);

            isDraggingHotspot = true;
            const containerRect = document.getElementById('visual-hotspots-container').getBoundingClientRect();
            const hotspotData = gameLocations[currentLocationId].hotspots[index];

            const startX = (hotspotData.position.x / 100) * containerRect.width;
            const startY = (hotspotData.position.y / 100) * containerRect.height;

            hotspotDragOffset.x = e.clientX - containerRect.left - startX;
            hotspotDragOffset.y = e.clientY - containerRect.top - startY;

            document.addEventListener('mousemove', handleHotspotMouseMove);
            document.addEventListener('mouseup', handleHotspotMouseUp);
        }

        function handleHotspotMouseMove(e) {
            if (!isDraggingHotspot) return;
            e.stopPropagation();

            const container = document.getElementById('visual-hotspots-container');
            const containerRect = container.getBoundingClientRect();
            const hotspot = gameLocations[currentLocationId].hotspots[selectedHotspotIndex];

            let newX = e.clientX - containerRect.left - hotspotDragOffset.x;
            let newY = e.clientY - containerRect.top - hotspotDragOffset.y;

            let newXPercent = (newX / containerRect.width) * 100;
            let newYPercent = (newY / containerRect.height) * 100;

            // Calcular delta de movimento
            const deltaX = newXPercent - hotspot.position.x;
            const deltaY = newYPercent - hotspot.position.y;

            // Clamp to bounds
            newXPercent = Math.max(0, Math.min(100 - hotspot.position.width, newXPercent));
            newYPercent = Math.max(0, Math.min(100 - hotspot.position.height, newYPercent));

            // Atualizar position
            hotspot.position.x = newXPercent;
            hotspot.position.y = newYPercent;

            // Se tem corners, mover todos os cantos junto
            if (hotspot.corners) {
                hotspot.corners.forEach(corner => {
                    corner.x += deltaX;
                    corner.y += deltaY;
                });
            }

            renderPositionedHotspots(); // Re-render to show movement
        }

        function handleHotspotMouseUp(e) {
            if (isDraggingHotspot) {
                isDraggingHotspot = false;
                autoSave();
            }
            document.removeEventListener('mousemove', handleHotspotMouseMove);
            document.removeEventListener('mouseup', handleHotspotMouseUp);
        }

        let draggedCornerIndex = -1;

        function handleCornerMouseDown(e) {
            e.stopPropagation();
            isResizingHotspot = true;
            draggedCornerIndex = parseInt(e.target.dataset.cornerIndex);

            document.addEventListener('mousemove', handleCornerMouseMove);
            document.addEventListener('mouseup', handleCornerMouseUp);
        }

        function handleCornerMouseMove(e) {
            if (!isResizingHotspot || draggedCornerIndex < 0) return;
            e.stopPropagation();

            const container = document.getElementById('visual-hotspots-container');
            const containerRect = container.getBoundingClientRect();
            const hotspot = gameLocations[currentLocationId].hotspots[selectedHotspotIndex];

            const mouseX = e.clientX - containerRect.left;
            const mouseY = e.clientY - containerRect.top;

            const mouseXPercent = Math.max(0, Math.min(100, (mouseX / containerRect.width) * 100));
            const mouseYPercent = Math.max(0, Math.min(100, (mouseY / containerRect.height) * 100));

            // Atualizar apenas o canto sendo arrastado
            if (hotspot.corners && hotspot.corners[draggedCornerIndex]) {
                hotspot.corners[draggedCornerIndex].x = mouseXPercent;
                hotspot.corners[draggedCornerIndex].y = mouseYPercent;

                // Atualizar position para manter compatibilidade (bounding box)
                const xs = hotspot.corners.map(c => c.x);
                const ys = hotspot.corners.map(c => c.y);
                hotspot.position.x = Math.min(...xs);
                hotspot.position.y = Math.min(...ys);
                hotspot.position.width = Math.max(...xs) - hotspot.position.x;
                hotspot.position.height = Math.max(...ys) - hotspot.position.y;
            }

            renderPositionedHotspots();
        }

        async function handleCornerMouseUp(e) {
            if (isResizingHotspot) {
                isResizingHotspot = false;
                draggedCornerIndex = -1;

                // Salvar no IndexedDB sem debounce
                const saveData = {
                    locations: gameLocations,
                    order: locationOrder
                };
                await saveToIndexedDB('editorData', saveData);

                // Cancelar qualquer timer pendente (evitar sync duplicado)
                if (autoSaveTimer) {
                    clearTimeout(autoSaveTimer);
                    autoSaveTimer = null;
                }

                // Sync imediato ao MySQL
                await syncToDatabase(true);
            }
            document.removeEventListener('mousemove', handleCornerMouseMove);
            document.removeEventListener('mouseup', handleCornerMouseUp);
        }

        function showSelectDialog(title, currentValue, options, defaultValue) {
            return new Promise((resolve) => {
                // Criar modal
                const modal = document.createElement('div');
                modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10000;';

                const dialog = document.createElement('div');
                dialog.style.cssText = 'background: #1a1a2e; padding: 30px; border-radius: 10px; border: 2px solid #f0a500; min-width: 400px;';

                const titleEl = document.createElement('h3');
                titleEl.textContent = title;
                titleEl.style.cssText = 'color: #f0a500; margin: 0 0 10px 0;';

                const currentEl = document.createElement('p');
                currentEl.textContent = currentValue;
                currentEl.style.cssText = 'color: #888; margin: 0 0 20px 0; font-size: 14px;';

                const select = document.createElement('select');
                select.style.cssText = 'width: 100%; padding: 10px; font-size: 16px; background: #0f0f1e; color: #e0e0e0; border: 2px solid #f0a500; border-radius: 5px; margin-bottom: 20px;';

                options.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt.value;
                    option.textContent = opt.label;
                    if (opt.value === defaultValue) option.selected = true;
                    select.appendChild(option);
                });

                const btnContainer = document.createElement('div');
                btnContainer.style.cssText = 'display: flex; gap: 10px;';

                const btnOk = document.createElement('button');
                btnOk.textContent = '‚úÖ OK';
                btnOk.style.cssText = 'flex: 1; padding: 10px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;';
                btnOk.onclick = () => {
                    document.body.removeChild(modal);
                    resolve(select.value);
                };

                const btnCancel = document.createElement('button');
                btnCancel.textContent = '‚ùå Cancelar';
                btnCancel.style.cssText = 'flex: 1; padding: 10px; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;';
                btnCancel.onclick = () => {
                    document.body.removeChild(modal);
                    resolve(null);
                };

                btnContainer.appendChild(btnOk);
                btnContainer.appendChild(btnCancel);

                dialog.appendChild(titleEl);
                dialog.appendChild(currentEl);
                dialog.appendChild(select);
                dialog.appendChild(btnContainer);

                modal.appendChild(dialog);
                document.body.appendChild(modal);

                select.focus();
            });
        }

        async function editVisualHotspot(index) {
            if (!currentLocationId) return;

            const location = gameLocations[currentLocationId];
            const hotspot = location.hotspots[index];

            // Usar modal para editar nome e destino
            let hotspotData;
            try {
                hotspotData = await showHotspotNavModal(hotspot.name || '', hotspot.target || '');
            } catch (err) {
                return; // Cancelado
            }

            const oldTarget = hotspot.target;

            // ‚úÖ Select para dire√ß√£o da seta
            const arrowOptions = [
                { value: '', label: '(Nenhuma)' },
                { value: 'up', label: '‚¨ÜÔ∏è Up - Frente' },
                { value: 'down', label: '‚¨áÔ∏è Down - Tr√°s/Voltar' },
                { value: 'left', label: '‚¨ÖÔ∏è Left - Esquerda' },
                { value: 'right', label: '‚û°Ô∏è Right - Direita' }
            ];
            const newDirection = await showSelectDialog(
                'Dire√ß√£o da Seta (Teclado)',
                `Atual: ${hotspot.arrowDirection || '(nenhuma)'}`,
                arrowOptions,
                hotspot.arrowDirection || ''
            );
            if (newDirection === null) return;

            hotspot.name = hotspotData.name;
            hotspot.target = hotspotData.target;

            // ‚úÖ Salvar dire√ß√£o da seta (s√≥ se for uma dire√ß√£o v√°lida)
            const validDirections = ['up', 'down', 'left', 'right'];
            if (newDirection && validDirections.includes(newDirection.toLowerCase())) {
                hotspot.arrowDirection = newDirection.toLowerCase();
            } else {
                // Remove o campo se vazio ou inv√°lido
                delete hotspot.arrowDirection;
            }

            // ‚úÖ Select para tipo de zoom
            const zoomOptions = [
                { value: '', label: '(Nenhum)' },
                { value: 'in', label: 'üîç+ In - Entrar/Aproximar' },
                { value: 'out', label: 'üîç- Out - Sair/Afastar' }
            ];
            const newZoom = await showSelectDialog(
                'Tipo de Zoom (Navega√ß√£o)',
                `Atual: ${hotspot.zoomDirection || '(nenhum)'}`,
                zoomOptions,
                hotspot.zoomDirection || ''
            );
            if (newZoom === null) return;

            // ‚úÖ Salvar dire√ß√£o do zoom (s√≥ se for uma dire√ß√£o v√°lida)
            const validZooms = ['in', 'out'];
            if (newZoom && validZooms.includes(newZoom.toLowerCase())) {
                hotspot.zoomDirection = newZoom.toLowerCase();
            } else {
                // Remove o campo se vazio ou inv√°lido
                delete hotspot.zoomDirection;
            }

            if (oldTarget !== hotspotData.target) {
                if (!location.connections) location.connections = [];
                if (!location.connections.includes(hotspotData.target)) {
                    location.connections.push(hotspotData.target);
                }
            }

            // ‚úÖ Salvar localmente (IndexedDB) - para sincronizar com banco, clique em "üíæ Salvar"
            const saveData = {
                locations: gameLocations,
                order: locationOrder
            };
            saveToIndexedDB('editorData', saveData);

            renderVisualHotspotsList();
            renderPositionedHotspots();
        }



        function deleteVisualHotspot(index) {
            if (!currentLocationId) return;
            if (!confirm('Remover este hotspot?')) return;

            const location = gameLocations[currentLocationId];
            location.hotspots.splice(index, 1);

            autoSave();
            renderVisualHotspotsList();
            renderPositionedHotspots();
        }

        // Fun√ß√£o de debug para verificar hotspots e connections
        function debugLocation(locationId) {
            const loc = gameLocations[locationId];
            if (!loc) {
                console.error('‚ùå Local n√£o encontrado:', locationId);
                return;
            }


            if (loc.hotspots) {
                loc.hotspots.forEach((h, i) => {
                    if (h.action === 'navigate') {
                        const temConexao = loc.connections?.includes(h.target);
                    }
                });
            }
        }

        // Disponibilizar no console global
        window.debugLocation = debugLocation;
        window.gameLocations = gameLocations;

        // ==================== VISUAL WALLS ====================
        let isDraggingWall = false;
        let isResizingWall = false;
        let wallDragOffset = { x: 0, y: 0 };
        let wallResizeHandle = null;

        function selectWall(index) {
            selectedVisualType = 'wall';
            selectedWallIndex = index;
            selectedItemIndex = null;
            renderPositionedWalls();
            renderTransformControls();
            renderVisualWallsList();
        }

        function renderPositionedWalls() {
            if (!currentLocationId) return;

            const location = gameLocations[currentLocationId];
            const container = document.getElementById('visual-walls-container');
            if (!container) return;

            const visualImage = document.getElementById('visual-location-image');
            const wrapper = document.getElementById('visual-wrapper');
            if (!visualImage || !visualImage.naturalWidth || !wrapper) {
                container.innerHTML = '';
                return;
            }

            const imgRect = visualImage.getBoundingClientRect();
            const wrapperRect = wrapper.getBoundingClientRect();
            const scale = imgRect.width / (visualImage.naturalWidth || imgRect.width);

            container.style.width = visualImage.naturalWidth + 'px';
            container.style.height = visualImage.naturalHeight + 'px';
            container.style.transform = `scale(${scale})`;
            container.style.transformOrigin = 'top left';
            container.style.left = (imgRect.left - wrapperRect.left) + 'px';
            container.style.top = (imgRect.top - wrapperRect.top) + 'px';

            container.innerHTML = '';

            if (!location.destructibleWalls) return;

            location.destructibleWalls.forEach((wall, index) => {
                const isSelected = index === selectedWallIndex;

                const wallEl = document.createElement('div');
                wallEl.dataset.wallIndex = index;
                wallEl.style.cssText = `
            position: absolute;
            left: ${wall.x}%;
            top: ${wall.y}%;
            width: ${wall.width}%;
            height: ${wall.height}%;
            border: 3px solid ${isSelected ? '#ff4444' : '#555'};
            cursor: move;
            pointer-events: auto;
            z-index: 40;
            overflow: hidden;
            `;

                // Adicionar imagem como elemento <img> se existir
                if (wall.image) {
                    const img = document.createElement('img');
                    img.src = wall.image;
                    img.style.cssText = `
                width: 100%;
                height: 100%;
                object-fit: cover;
                pointer-events: none;
                display: block;
                `;
                    img.onerror = function() {
                        // Se a imagem n√£o carregar, mostrar background colorido
                        wallEl.style.background = isSelected ? 'rgba(255, 68, 68, 0.3)' : 'rgba(85, 85, 85, 0.5)';
                        this.style.display = 'none';
                    };
                    wallEl.appendChild(img);
                } else {
                    // Sem imagem, usar cor de fundo
                    wallEl.style.background = isSelected ? 'rgba(255, 68, 68, 0.3)' : 'rgba(85, 85, 85, 0.5)';
                }

                const label = document.createElement('div');
                label.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            white-space: nowrap;
            `;
                label.textContent = wall.id || 'Parede';
                wallEl.appendChild(label);

                wallEl.addEventListener('mousedown', handleWallMouseDown);

                if (isSelected) {
                    const handles = ['nw', 'ne', 'sw', 'se'];
                    handles.forEach(handle => {
                        const handleEl = document.createElement('div');
                        handleEl.className = 'resize-handle';
                        handleEl.dataset.direction = handle;
                        handleEl.style.cssText = `
            position: absolute;
            width: 12px; height: 12px;
            background: #ff4444; border: 1px solid white;
            z-index: 100;
            cursor: ${handle}-resize;
            `;
                        if (handle.includes('n')) handleEl.style.top = '-6px';
                        if (handle.includes('s')) handleEl.style.bottom = '-6px';
                        if (handle.includes('w')) handleEl.style.left = '-6px';
                        if (handle.includes('e')) handleEl.style.right = '-6px';

                        handleEl.addEventListener('mousedown', handleWallResizeMouseDown);
                        wallEl.appendChild(handleEl);
                    });
                }

                container.appendChild(wallEl);
            });
        }

        function handleWallMouseDown(e) {
            e.stopPropagation();
            const index = parseInt(e.target.closest('[data-wall-index]').dataset.wallIndex);
            selectWall(index);

            isDraggingWall = true;
            const containerRect = document.getElementById('visual-walls-container').getBoundingClientRect();
            const wall = gameLocations[currentLocationId].destructibleWalls[index];

            const startX = (wall.x / 100) * containerRect.width;
            const startY = (wall.y / 100) * containerRect.height;

            wallDragOffset.x = e.clientX - containerRect.left - startX;
            wallDragOffset.y = e.clientY - containerRect.top - startY;

            document.addEventListener('mousemove', handleWallMouseMove);
            document.addEventListener('mouseup', handleWallMouseUp);
        }

        function handleWallMouseMove(e) {
            if (!isDraggingWall) return;
            e.stopPropagation();

            const container = document.getElementById('visual-walls-container');
            const containerRect = container.getBoundingClientRect();
            const wall = gameLocations[currentLocationId].destructibleWalls[selectedWallIndex];

            let newX = e.clientX - containerRect.left - wallDragOffset.x;
            let newY = e.clientY - containerRect.top - wallDragOffset.y;

            let newXPercent = (newX / containerRect.width) * 100;
            let newYPercent = (newY / containerRect.height) * 100;

            wall.x = newXPercent;
            wall.y = newYPercent;

            renderPositionedWalls();
        }

        function handleWallMouseUp(e) {
            if (isDraggingWall) {
                isDraggingWall = false;
                autoSave();
                renderDestructibleWallsList(); // Update list values
            }
            document.removeEventListener('mousemove', handleWallMouseMove);
            document.removeEventListener('mouseup', handleWallMouseUp);
        }

        function handleWallResizeMouseDown(e) {
            e.stopPropagation();
            isResizingWall = true;
            wallResizeHandle = e.target.dataset.direction;

            document.addEventListener('mousemove', handleWallResizeMouseMove);
            document.addEventListener('mouseup', handleWallResizeMouseUp);
        }

        function handleWallResizeMouseMove(e) {
            if (!isResizingWall) return;
            e.stopPropagation();

            const container = document.getElementById('visual-walls-container');
            const containerRect = container.getBoundingClientRect();
            const wall = gameLocations[currentLocationId].destructibleWalls[selectedWallIndex];

            const mouseX = e.clientX - containerRect.left;
            const mouseY = e.clientY - containerRect.top;

            const mouseXPercent = (mouseX / containerRect.width) * 100;
            const mouseYPercent = (mouseY / containerRect.height) * 100;

            const right = wall.x + wall.width;
            const bottom = wall.y + wall.height;

            if (wallResizeHandle.includes('e')) {
                wall.width = Math.max(1, mouseXPercent - wall.x);
            }
            if (wallResizeHandle.includes('s')) {
                wall.height = Math.max(1, mouseYPercent - wall.y);
            }
            if (wallResizeHandle.includes('w')) {
                wall.width = Math.max(1, right - mouseXPercent);
                wall.x = mouseXPercent;
            }
            if (wallResizeHandle.includes('n')) {
                wall.height = Math.max(1, bottom - mouseYPercent);
                wall.y = mouseYPercent;
            }

            renderPositionedWalls();
        }

        function handleWallResizeMouseUp(e) {
            if (isResizingWall) {
                isResizingWall = false;
                autoSave();
                renderDestructibleWallsList(); // Update list values
            }
            document.removeEventListener('mousemove', handleWallResizeMouseMove);
            document.removeEventListener('mouseup', handleWallResizeMouseUp);
        }

        // ==================== DESTRUCTIBLE WALLS ====================
        function renderDestructibleWallsList() {
            if (!currentLocationId) return;

            const location = gameLocations[currentLocationId];
            const list = document.getElementById('wallsList');
            list.innerHTML = '';

            if (!location.destructibleWalls || location.destructibleWalls.length === 0) {
                list.innerHTML = '<div style="color: #999; font-size: 14px; margin-bottom: 15px;">Nenhuma parede configurada.</div>';
                return;
            }

            location.destructibleWalls.forEach((wall, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'list-item';
                itemDiv.innerHTML = `
                < div class="list-item-content" >
                        <div class="form-row-3">
                            <div class="form-group" style="margin-bottom: 0;">
                                <label style="font-size: 11px;">ID</label>
                                <input type="text" value="${wall.id || ''}" onchange="updateDestructibleWall(${index}, 'id', this.value)" placeholder="wall_id">
                            </div>
                            <div class="form-group" style="margin-bottom: 0;">
                                <label style="font-size: 11px;">Item Necess√°rio</label>
                                <input type="text" value="${wall.requiredItem || 'gun'}" onchange="updateDestructibleWall(${index}, 'requiredItem', this.value)" placeholder="gun">
                            </div>
                            <div class="form-group" style="margin-bottom: 0;">
                                <label style="font-size: 11px;">Imagem</label>
                                <input type="text" value="${wall.image || ''}" onchange="updateDestructibleWall(${index}, 'image', this.value)" placeholder="wall.png">
                            </div>
                        </div>
                        <div class="form-row" style="margin-top: 10px;">
                            <div class="form-group" style="margin-bottom: 0;">
                                <label style="font-size: 11px;">Posi√ß√£o (X, Y %)</label>
                                <div style="display: flex; gap: 5px;">
                                    <input type="number" value="${wall.x || 0}" onchange="updateDestructibleWall(${index}, 'x', parseFloat(this.value))" style="width: 50%;">
                                    <input type="number" value="${wall.y || 0}" onchange="updateDestructibleWall(${index}, 'y', parseFloat(this.value))" style="width: 50%;">
                                </div>
                            </div>
                            <div class="form-group" style="margin-bottom: 0;">
                                <label style="font-size: 11px;">Tamanho (W, H %)</label>
                                <div style="display: flex; gap: 5px;">
                                    <input type="number" value="${wall.width || 10}" onchange="updateDestructibleWall(${index}, 'width', parseFloat(this.value))" style="width: 50%;">
                                    <input type="number" value="${wall.height || 20}" onchange="updateDestructibleWall(${index}, 'height', parseFloat(this.value))" style="width: 50%;">
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="list-item-actions" style="flex-direction: column;">
                        <button class="btn btn-danger btn-small" onclick="deleteDestructibleWall(${index})">üóëÔ∏è</button>
                    </div>
                `;
                list.appendChild(itemDiv);
            });
        }

        function addNewDestructibleWall() {
            if (!currentLocationId) return;
            const location = gameLocations[currentLocationId];

            if (!location.destructibleWalls) {
                location.destructibleWalls = [];
            }

            location.destructibleWalls.push({
                id: `wall_${Date.now()}`,
                x: 50,
                y: 50,
                width: 15,
                height: 25,
                image: '',
                requiredItem: 'gun'
            });

            autoSave();
            renderDestructibleWallsList();
            renderPositionedWalls();
        }

        function updateDestructibleWall(index, field, value) {
            if (!currentLocationId) return;
            const location = gameLocations[currentLocationId];

            if (location.destructibleWalls && location.destructibleWalls[index]) {
                location.destructibleWalls[index][field] = value;
                autoSave();
                renderPositionedWalls();
            }
        }

        function deleteDestructibleWall(index) {
            if (!currentLocationId) return;
            if (!confirm('Tem certeza que deseja remover esta parede?')) return;

            const location = gameLocations[currentLocationId];
            if (location.destructibleWalls) {
                location.destructibleWalls.splice(index, 1);
                autoSave();
                renderDestructibleWallsList();
                renderPositionedWalls();
            }
        }

        // Carregar dados ao iniciar
        window.addEventListener('DOMContentLoaded', () => {
            loadFromLocalStorage();
        });

        // F4 para testar o jogo e voltar no mesmo lugar
        document.addEventListener('keydown', (e) => {
            // F4 key
            if (e.key === 'F4' || e.keyCode === 115) {
                e.preventDefault();

                // Salvar localiza√ß√£o atual antes de ir para o jogo
                if (currentLocationId) {
                    localStorage.setItem('editor_last_location', currentLocationId);
                }

                // Ir para o jogo
                window.location.href = 'game-phaser.html';
            }
        });

        // Inicializar eventos de desenho de hotspots
        window.addEventListener('load', () => {
            const visualWrapper = document.getElementById('visual-wrapper');
            if (!visualWrapper) return;

            visualWrapper.addEventListener('mousedown', (e) => {
                if (!isDrawingHotspot) return;

                const visualImage = document.getElementById('visual-location-image');
                const imgRect = visualImage.getBoundingClientRect();

                // Verificar se clicou na imagem
                if (e.clientX < imgRect.left || e.clientX > imgRect.right ||
                    e.clientY < imgRect.top || e.clientY > imgRect.bottom) {
                    return;
                }

                hotspotStartX = e.clientX - imgRect.left;
                hotspotStartY = e.clientY - imgRect.top;

                // Criar ret√¢ngulo tempor√°rio
                const container = document.getElementById('visual-hotspots-container');
                currentDrawingRect = document.createElement('div');
                currentDrawingRect.style.cssText = `
                    position: absolute;
                    border: 3px dashed #28a745;
                    background: rgba(40, 167, 69, 0.3);
                    pointer-events: none;
                    z-index: 200;
                `;

                // Converter para coordenadas escaladas
                const scale = imgRect.width / (visualImage.naturalWidth || imgRect.width);
                currentDrawingRect.style.left = hotspotStartX / scale + 'px';
                currentDrawingRect.style.top = hotspotStartY / scale + 'px';

                container.appendChild(currentDrawingRect);
            });

            visualWrapper.addEventListener('mousemove', (e) => {
                if (!isDrawingHotspot || !currentDrawingRect) return;

                const visualImage = document.getElementById('visual-location-image');
                const imgRect = visualImage.getBoundingClientRect();

                const currentX = e.clientX - imgRect.left;
                const currentY = e.clientY - imgRect.top;

                const width = Math.abs(currentX - hotspotStartX);
                const height = Math.abs(currentY - hotspotStartY);
                const left = Math.min(hotspotStartX, currentX);
                const top = Math.min(hotspotStartY, currentY);

                const scale = imgRect.width / (visualImage.naturalWidth || imgRect.width);

                currentDrawingRect.style.left = left / scale + 'px';
                currentDrawingRect.style.top = top / scale + 'px';
                currentDrawingRect.style.width = width / scale + 'px';
                currentDrawingRect.style.height = height / scale + 'px';
            });

            visualWrapper.addEventListener('mouseup', async (e) => {
                if (!isDrawingHotspot || !currentDrawingRect) return;

                const visualImage = document.getElementById('visual-location-image');
                const imgRect = visualImage.getBoundingClientRect();

                const currentX = e.clientX - imgRect.left;
                const currentY = e.clientY - imgRect.top;

                const width = Math.abs(currentX - hotspotStartX);
                const height = Math.abs(currentY - hotspotStartY);

                // M√≠nimo 20px de √°rea
                if (width < 20 || height < 20) {
                    currentDrawingRect.remove();
                    currentDrawingRect = null;
                    showToast('‚ö†Ô∏è √Årea muito pequena', 'warning');
                    return;
                }

                // Converter para porcentagem
                const x = (Math.min(hotspotStartX, currentX) / imgRect.width) * 100;
                const y = (Math.min(hotspotStartY, currentY) / imgRect.height) * 100;
                const w = (width / imgRect.width) * 100;
                const h = (height / imgRect.height) * 100;

                // Pedir informa√ß√µes via modal
                let hotspotData;
                try {
                    hotspotData = await showHotspotNavModal();
                } catch (err) {
                    // Cancelado
                    currentDrawingRect.remove();
                    currentDrawingRect = null;
                    isDrawingHotspot = false;
                    return;
                }

                // Salvar hotspot
                const location = gameLocations[currentLocationId];
                if (!location.hotspots) location.hotspots = [];

                const newHotspot = {
                    id: 'hotspot_' + Date.now(),
                    name: hotspotData.name,
                    action: 'navigate',
                    target: hotspotData.target,
                    position: {
                        x: x,
                        y: y,
                        width: w,
                        height: h
                    },
                    corners: [
                        { x: x, y: y },                     // top-left
                        { x: x + w, y: y },                 // top-right
                        { x: x + w, y: y + h },             // bottom-right
                        { x: x, y: y + h }                  // bottom-left
                    ]
                };

                location.hotspots.push(newHotspot);

                // Adicionar conex√£o automaticamente se n√£o existir
                if (!location.connections) location.connections = [];
                if (!location.connections.includes(hotspotData.target)) {
                    location.connections.push(hotspotData.target);
                }

                autoSave();

                currentDrawingRect.remove();
                currentDrawingRect = null;
                isDrawingHotspot = false;

                renderVisualHotspotsList();
                renderPositionedHotspots();

                showToast('‚úÖ Hotspot criado!');
            });
        });

        // Switch tabs
        function switchTab(tabName) {
            currentTab = tabName;

            // Remover active de todos os bot√µes e pain√©is
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));

            // Ativar o bot√£o correto (buscar pelo texto ou data-attribute)
            const buttons = document.querySelectorAll('.tab-btn');
            buttons.forEach(btn => {
                if (btn.getAttribute('onclick')?.includes(`'${tabName}'`)) {
                    btn.classList.add('active');
                }
            });

            // Ativar o painel correto
            const panel = document.getElementById('tab-' + tabName);
            if (panel) {
                panel.classList.add('active');
            }

            // Load visual editor when switching to visual tab
            if (tabName === 'visual') {
                loadVisualEditor();
            }
        }

        // Save basic info
        function toggleCreditsSection() {
            const isChecked = document.getElementById('edit-final-scene').checked;
            const creditsSection = document.getElementById('credits-section');
            const videoSection = document.getElementById('transition-video-section');
            const dramaticSection = document.getElementById('dramatic-messages-section');
            creditsSection.style.display = isChecked ? 'block' : 'none';
            videoSection.style.display = isChecked ? 'block' : 'none';
            dramaticSection.style.display = isChecked ? 'block' : 'none';
        }

        function addCreditLine() {
            const container = document.getElementById('credits-list');
            const index = container.children.length;

            const creditEl = document.createElement('div');
            creditEl.style.cssText = `
                background: white;
                padding: 15px;
                margin-bottom: 10px;
                border-radius: 6px;
                border: 1px solid #ddd;
            `;
            creditEl.dataset.index = index;

            creditEl.innerHTML = `
                <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 10px;">
                    <strong>Texto ${index + 1}</strong>
                    <button class="btn btn-danger btn-small" onclick="removeCreditLine(${index})" style="margin-left: auto;">üóëÔ∏è</button>
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="font-size: 12px; color: #666;">Texto:</label>
                    <textarea id="credit-text-${index}" placeholder="Digite o texto do cr√©dito..." onchange="saveBasicInfo()"
                              style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; min-height: 60px;"></textarea>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                    <div>
                        <label style="font-size: 12px; color: #666;">Fonte:</label>
                        <input type="text" id="credit-font-${index}" placeholder="Arial, sans-serif" onchange="saveBasicInfo()"
                               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
                    </div>
                    <div>
                        <label style="font-size: 12px; color: #666;">Tamanho:</label>
                        <input type="text" id="credit-size-${index}" placeholder="48px" value="48px" onchange="saveBasicInfo()"
                               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <div>
                        <label style="font-size: 12px; color: #666;">Cor:</label>
                        <input type="text" id="credit-color-${index}" placeholder="#feda4a" value="#feda4a" onchange="saveBasicInfo()"
                               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
                    </div>
                    <div>
                        <label style="font-size: 12px; color: #666;">Peso:</label>
                        <select id="credit-weight-${index}" onchange="saveBasicInfo()"
                                style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
                            <option value="normal">Normal</option>
                            <option value="bold" selected>Bold</option>
                            <option value="lighter">Lighter</option>
                        </select>
                    </div>
                </div>
            `;

            container.appendChild(creditEl);
            saveBasicInfo();
            syncToDatabase(true); // Auto-sync to MySQL
        }

        function removeCreditLine(index) {
            const container = document.getElementById('credits-list');
            const element = container.querySelector(`[data-index="${index}"]`);
            if (element) {
                element.remove();
                // Reindexar
                Array.from(container.children).forEach((el, i) => {
                    el.dataset.index = i;
                });
                saveBasicInfo();
                syncToDatabase(true); // Auto-sync to MySQL
            }
        }

        function collectCreditsData() {
            const container = document.getElementById('credits-list');
            const credits = [];

            Array.from(container.children).forEach((el, index) => {
                const text = document.getElementById(`credit-text-${index}`)?.value || '';
                const font = document.getElementById(`credit-font-${index}`)?.value || 'Arial, sans-serif';
                const fontSize = document.getElementById(`credit-size-${index}`)?.value || '48px';
                const color = document.getElementById(`credit-color-${index}`)?.value || '#feda4a';
                const fontWeight = document.getElementById(`credit-weight-${index}`)?.value || 'bold';

                if (text.trim()) {
                    credits.push({ text, font, fontSize, color, fontWeight });
                }
            });

            return credits;
        }

        function loadCreditsData(credits) {
            const container = document.getElementById('credits-list');
            container.innerHTML = '';

            credits.forEach((credit, index) => {
                // Criar o elemento
                const creditEl = document.createElement('div');
                creditEl.style.cssText = `
                    background: white;
                    padding: 15px;
                    margin-bottom: 10px;
                    border-radius: 6px;
                    border: 1px solid #ddd;
                `;
                creditEl.dataset.index = index;

                creditEl.innerHTML = `
                    <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 10px;">
                        <strong>Texto ${index + 1}</strong>
                        <button class="btn btn-danger btn-small" onclick="removeCreditLine(${index})" style="margin-left: auto;">üóëÔ∏è</button>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 12px; color: #666;">Texto:</label>
                        <textarea id="credit-text-${index}" placeholder="Digite o texto do cr√©dito..." onchange="saveBasicInfo()"
                                  style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; min-height: 60px;">${credit.text}</textarea>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                        <div>
                            <label style="font-size: 12px; color: #666;">Fonte:</label>
                            <input type="text" id="credit-font-${index}" placeholder="Arial, sans-serif" value="${credit.font || 'Arial, sans-serif'}" onchange="saveBasicInfo()"
                                   style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
                        </div>
                        <div>
                            <label style="font-size: 12px; color: #666;">Tamanho:</label>
                            <input type="text" id="credit-size-${index}" placeholder="48px" value="${credit.fontSize || '48px'}" onchange="saveBasicInfo()"
                                   style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div>
                            <label style="font-size: 12px; color: #666;">Cor:</label>
                            <input type="text" id="credit-color-${index}" placeholder="#feda4a" value="${credit.color || '#feda4a'}" onchange="saveBasicInfo()"
                                   style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
                        </div>
                        <div>
                            <label style="font-size: 12px; color: #666;">Peso:</label>
                            <select id="credit-weight-${index}" onchange="saveBasicInfo()"
                                    style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
                                <option value="normal" ${credit.fontWeight === 'normal' ? 'selected' : ''}>Normal</option>
                                <option value="bold" ${credit.fontWeight === 'bold' || !credit.fontWeight ? 'selected' : ''}>Bold</option>
                                <option value="lighter" ${credit.fontWeight === 'lighter' ? 'selected' : ''}>Lighter</option>
                            </select>
                        </div>
                    </div>
                `;

                container.appendChild(creditEl);
            });
        }

        function saveBasicInfo(triggerAutoSave = true) {
            if (!currentLocationId) return;

            // ‚úÖ SEMPRE salvar na mem√≥ria (gameLocations)
            // S√≥ n√£o sincroniza com banco se autoSaveEnabled for false

            const oldId = currentLocationId;
            const newId = document.getElementById('edit-id').value.trim();

            // Update location data
            const location = gameLocations[oldId];
            location.id = newId;
            location.name = document.getElementById('edit-name').value;
            location.description = document.getElementById('edit-description').value;
            location.image = document.getElementById('edit-image').value;
            location.unlocked = document.getElementById('edit-unlocked').checked;
            location.isFinalScene = document.getElementById('edit-final-scene').checked;
            location.transitionVideo = document.getElementById('edit-transition-video').value.trim();
            location.dramaticMessages = document.getElementById('edit-dramatic-messages').value.trim();
            location.dramaticMessageDuration = parseInt(document.getElementById('edit-dramatic-duration').value) || 5;

            // Salvar cr√©ditos se for cena final
            if (location.isFinalScene) {
                location.credits = collectCreditsData();
                if (!location.transitionVideo) {
                    delete location.transitionVideo;
                }
                if (!location.dramaticMessages) {
                    delete location.dramaticMessages;
                    delete location.dramaticMessageDuration;
                }
            } else {
                delete location.credits;
                delete location.transitionVideo;
                delete location.dramaticMessages;
                delete location.dramaticMessageDuration;
            }

            // If ID changed, update the object key and all connections
            if (oldId !== newId) {
                if (gameLocations[newId]) {
                    showToast('‚ùå ID j√° existe!', 'error');
                    return;
                }

                gameLocations[newId] = location;
                delete gameLocations[oldId];

                // Update connections in all locations
                Object.values(gameLocations).forEach(loc => {
                    if (loc.connections) {
                        const idx = loc.connections.indexOf(oldId);
                        if (idx > -1) loc.connections[idx] = newId;
                    }
                    if (loc.hotspots) {
                        loc.hotspots.forEach(hotspot => {
                            if (hotspot.target === oldId) hotspot.target = newId;
                        });
                    }
                });

                currentLocationId = newId;

                // Update locationOrder array
                const orderIndex = locationOrder.indexOf(oldId);
                if (orderIndex > -1) {
                    locationOrder[orderIndex] = newId;
                }
            }

            // ‚úÖ S√≥ sincronizar com IndexedDB/banco se autoSaveEnabled estiver true
            if (triggerAutoSave && autoSaveEnabled) {
                autoSave();
                showToast('‚úì Informa√ß√µes salvas!');
            }
            renderLocationsList();
        }

        // Toggle puzzle editor
        function togglePuzzleEditor() {
            const hasPuzzle = document.getElementById('has-puzzle').checked;

            document.getElementById('puzzle-editor').style.display = hasPuzzle ? 'block' : 'none';

            // üîß Quando marca "tem puzzle", auto-gerar ID se estiver vazio
            if (hasPuzzle && currentLocationId) {
                const puzzleIdField = document.getElementById('puzzle-id');
                if (!puzzleIdField.value.trim()) {
                    puzzleIdField.value = currentLocationId + '_puzzle';
                }
            }

            // Salvar automaticamente quando marcar/desmarcar
            savePuzzle();
        }

        // Select puzzle type
        function selectPuzzleType(type) {
            currentPuzzleType = type;

            document.querySelectorAll('.puzzle-type-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.closest('.puzzle-type-btn').classList.add('selected');

            renderPuzzleOptions(type);
        }

        // Helper: HTML comum para a√ß√£o ao resolver puzzle
        function getUnlockActionHTML() {
            return `
                <div class="form-group" style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e0e0e0;">
                    <label style="font-size: 14px; font-weight: bold; color: #333;">üéØ A√ß√£o ao Resolver Enigma</label>
                    <select id="puzzle-unlock-action-type" onchange="savePuzzle(); toggleUnlockActionFields()">
                        <option value="">Nenhuma a√ß√£o (s√≥ mostrar mensagem)</option>
                        <option value="changeBackground">Trocar Imagem de Fundo</option>
                        <option value="navigate">Navegar para Outra Localiza√ß√£o</option>
                    </select>
                </div>
                <div class="form-group" id="unlock-new-background-group" style="display: none;">
                    <label>Nova Imagem de Fundo</label>
                    <input type="text" id="puzzle-new-background" placeholder="images/scenes/porta_aberta.jpg" onchange="savePuzzle()">
                    <div class="form-hint">Imagem mostrada ap√≥s resolver o enigma</div>
                </div>
                <div class="form-group" id="unlock-target-location-group" style="display: none;">
                    <label>Localiza√ß√£o de Destino</label>
                    <input type="text" id="puzzle-target-location" placeholder="sala_secreta" onchange="savePuzzle()">
                    <div class="form-hint">ID da localiza√ß√£o para navegar ap√≥s resolver</div>
                </div>
                <div class="form-group" id="unlock-message-group" style="display: none;">
                    <label>Mensagem Customizada (opcional)</label>
                    <input type="text" id="puzzle-unlock-message" placeholder="O caminho se abriu!" onchange="savePuzzle()">
                    <div class="form-hint">Mensagem mostrada ao executar a a√ß√£o</div>
                </div>
            `;
        }

        // Render puzzle options based on type
        function renderPuzzleOptions(type) {
            const container = document.getElementById('puzzle-options-container');

            const templates = {
                direction: `
                    <div class="form-group">
                        <label>Pergunta</label>
                        <textarea id="puzzle-question" placeholder="Digite a pergunta..." onchange="savePuzzle()"></textarea>
                    </div>
                    <div class="form-group">
                        <label>Op√ß√µes (uma por linha)</label>
                        <textarea id="puzzle-options" placeholder="Norte\nSul\nLeste\nOeste" onchange="savePuzzle()"></textarea>
                    </div>
                    <div class="form-group">
                        <label>Resposta Correta (n√∫mero da op√ß√£o, come√ßando em 0)</label>
                        <input type="number" id="puzzle-answer" placeholder="0" onchange="savePuzzle()">
                    </div>
                    <div class="form-group">
                        <label>Dica (opcional)</label>
                        <input type="text" id="puzzle-hint" placeholder="Dica..." onchange="savePuzzle()">
                    </div>
                `,
                riddle: `
                    <div class="form-group">
                        <label>Pergunta / Charada</label>
                        <textarea id="puzzle-question" placeholder="Digite a charada..." onchange="savePuzzle()"></textarea>
                    </div>
                    <div class="form-group">
                        <label>Op√ß√µes (uma por linha)</label>
                        <textarea id="puzzle-options" placeholder="Op√ß√£o 1\nOp√ß√£o 2\nOp√ß√£o 3\nOp√ß√£o 4" onchange="savePuzzle()"></textarea>
                    </div>
                    <div class="form-group">
                        <label>Resposta Correta (n√∫mero da op√ß√£o, come√ßando em 0)</label>
                        <input type="number" id="puzzle-answer" placeholder="0" onchange="savePuzzle()">
                    </div>
                `,
                sequence_symbols: `
                    <div class="form-group">
                        <label>Pergunta</label>
                        <textarea id="puzzle-question" placeholder="Digite a pergunta..." onchange="savePuzzle()"></textarea>
                    </div>
                    <div class="form-group">
                        <label>S√≠mbolos/Op√ß√µes Dispon√≠veis (um por linha)</label>
                        <textarea id="puzzle-options" placeholder="üåô Lua\n‚≠ê Estrela\n‚òÄÔ∏è Sol" onchange="savePuzzle()" rows="4"></textarea>
                        <div class="form-hint">Digite cada s√≠mbolo em uma linha. Podem ser emojis, texto, n√∫meros, etc.</div>
                    </div>
                    <div class="form-group">
                        <label>Sequ√™ncia Correta (n√∫meros separados por v√≠rgula, come√ßando em 0)</label>
                        <input type="text" id="puzzle-sequence" placeholder="0,2,1" onchange="savePuzzle()">
                        <div class="form-hint">Exemplo: 0,2,1 significa primeira op√ß√£o, terceira op√ß√£o, segunda op√ß√£o</div>
                    </div>
                `,
                math: `
                    <div class="form-group">
                        <label>Pergunta / Problema Matem√°tico</label>
                        <textarea id="puzzle-question" placeholder="Digite o problema..." onchange="savePuzzle()"></textarea>
                    </div>
                    <div class="form-group">
                        <label>Resposta Correta (n√∫mero)</label>
                        <input type="number" id="puzzle-answer" placeholder="42" onchange="savePuzzle()">
                    </div>
                `,
                code: `
                    <div class="form-group">
                        <label>Pergunta</label>
                        <textarea id="puzzle-question" placeholder="Digite a pergunta..." onchange="savePuzzle()"></textarea>
                    </div>
                    <div class="form-group">
                        <label>C√≥digo Correto (n√∫mero)</label>
                        <input type="number" id="puzzle-answer" placeholder="1234" onchange="savePuzzle()">
                    </div>
                    <div class="form-group">
                        <label>Dica (opcional)</label>
                        <input type="text" id="puzzle-hint" placeholder="Dica..." onchange="savePuzzle()">
                    </div>
                `,
                item_combination: `
                    <div class="form-group">
                        <label>Pergunta</label>
                        <textarea id="puzzle-question" placeholder="Digite a pergunta..." onchange="savePuzzle()"></textarea>
                    </div>
                    <div class="form-group">
                        <label>Itens Necess√°rios (IDs separados por v√≠rgula)</label>
                        <input type="text" id="puzzle-required-items" placeholder="item1, item2" onchange="savePuzzle()">
                    </div>

                    ${getUnlockActionHTML()}
                `,
                padlock_5digit: `
                    <div class="form-group">
                        <label>C√≥digo Secreto (5 d√≠gitos)</label>
                        <input type="text" id="puzzle-secret-code" maxlength="5" pattern="[0-9]{5}" placeholder="12345" onchange="savePuzzle()">
                        <div class="form-hint">Digite exatamente 5 n√∫meros (0-9)</div>
                    </div>

                    ${getUnlockActionHTML()}
                `,
                egyptian: `
                    <div class="form-group">
                        <label>T√≠tulo</label>
                        <input type="text" id="puzzle-title" placeholder="Parede Eg√≠pcia Antiga" onchange="savePuzzle()">
                    </div>
                    <div class="form-group">
                        <label>Descri√ß√£o</label>
                        <textarea id="puzzle-description" placeholder="S√≠mbolos eg√≠pcios gravados na parede..." onchange="savePuzzle()"></textarea>
                    </div>

                    <div class="form-group">
                        <label style="margin-bottom: 10px; display: block;">Configura√ß√£o das Pe√ßas (6 hex√°gonos)</label>
                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; border: 1px solid #ddd;">
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 15px;">
                                ${[1, 2, 3, 4, 5, 6].map(i => `
                                    <div style="background: white; padding: 10px; border-radius: 6px; border: 2px solid #e0e0e0;">
                                        <div style="font-weight: bold; margin-bottom: 8px; color: #333; text-align: center;">
                                            Pe√ßa ${i}
                                        </div>
                                        <div style="margin-bottom: 6px;">
                                            <label style="font-size: 11px; color: #666; display: block; margin-bottom: 3px;">Rota√ß√£o Inicial:</label>
                                            <select id="piece${i}-initial" onchange="savePuzzle()" style="width: 100%; padding: 5px; border-radius: 4px; border: 1px solid #ccc;">
                                                <option value="0">0¬∞ (‚Üë)</option>
                                                <option value="90">90¬∞ (‚Üí)</option>
                                                <option value="180">180¬∞ (‚Üì)</option>
                                                <option value="270">270¬∞ (‚Üê)</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label style="font-size: 11px; color: #666; display: block; margin-bottom: 3px;">Rota√ß√£o Correta:</label>
                                            <select id="piece${i}-correct" onchange="savePuzzle()" style="width: 100%; padding: 5px; border-radius: 4px; border: 1px solid #ccc;">
                                                <option value="0">0¬∞ (‚Üë)</option>
                                                <option value="90">90¬∞ (‚Üí)</option>
                                                <option value="180">180¬∞ (‚Üì)</option>
                                                <option value="270">270¬∞ (‚Üê)</option>
                                            </select>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                            <div style="font-size: 11px; color: #666; line-height: 1.4;">
                                <strong>Dica:</strong> Configure as rota√ß√µes iniciais (embaralhadas) e as rota√ß√µes corretas (solu√ß√£o).
                                O jogador precisa rotacionar cada pe√ßa at√© alcan√ßar a rota√ß√£o correta.
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Dicas (JSON array - opcional)</label>
                        <textarea id="puzzle-hints" placeholder='[{"text": "Procure os papiros..."}]' onchange="savePuzzle()"></textarea>
                        <div class="form-hint">Formato: Array de objetos com propriedade "text"</div>
                    </div>

                    ${getUnlockActionHTML()}
                `,
                shape_match: `
                    <div class="form-group">
                        <label>T√≠tulo</label>
                        <input type="text" id="puzzle-title" placeholder="Encaixe as Formas" onchange="savePuzzle()">
                    </div>
                    <div class="form-group">
                        <label>Descri√ß√£o</label>
                        <textarea id="puzzle-description" placeholder="Arraste os objetos do invent√°rio para os moldes corretos..." onchange="savePuzzle()"></textarea>
                    </div>

                    <div class="form-group">
                        <label style="margin-bottom: 10px; display: block;">Moldes na Cena</label>
                        <div id="molds-list" style="background: #f5f5f5; padding: 15px; border-radius: 8px; border: 1px solid #ddd; margin-bottom: 10px;">
                            <!-- Moldes ser√£o adicionados aqui dinamicamente -->
                        </div>
                        <button type="button" class="btn btn-secondary" onclick="addShapeMatchMold()" style="width: 100%;">
                            ‚ûï Adicionar Molde
                        </button>
                    </div>

                    <div class="form-group">
                        <label>Dicas (JSON array - opcional)</label>
                        <textarea id="puzzle-hints" placeholder='[{"text": "Observe as formas dos moldes..."}]' onchange="savePuzzle()"></textarea>
                        <div class="form-hint">Formato: Array de objetos com propriedade "text"</div>
                    </div>

                    ${getUnlockActionHTML()}
                `
            };

            container.innerHTML = templates[type] || '';
        }

        // üîç DEBUG: Fun√ß√£o para inspecionar puzzles (chamar no console)
        window.debugPuzzles = function() {
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('üîç DEBUG: Estado atual de todos os puzzles');
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('Location atual:', currentLocationId);
            console.log('Puzzle ID no campo de formul√°rio:', document.getElementById('puzzle-id').value);
            console.log('\nPuzzles em gameLocations:');
            for (const locId in gameLocations) {
                const loc = gameLocations[locId];
                if (loc.puzzle) {
                    console.log(`  üìç ${locId}:`);
                    console.log(`     Puzzle ID: ${loc.puzzle.id}`);
                    console.log(`     Type: ${loc.puzzle.type}`);
                    console.log(`     Objeto:`, loc.puzzle);
                } else {
                    console.log(`  üìç ${locId}: sem puzzle`);
                }
            }
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        };

        // Load puzzle data
        // Limpar todos os campos do formul√°rio de puzzle
        function clearPuzzleFormFields() {
            document.getElementById('puzzle-id').value = '';
            currentPuzzleType = null;

            // Desmarcar todos os bot√µes de tipo
            document.querySelectorAll('.puzzle-type-btn').forEach(btn => btn.classList.remove('selected'));

            // Limpar todos os campos poss√≠veis
            const fieldsToClear = [
                'puzzle-question',
                'puzzle-options',
                'puzzle-answer',
                'puzzle-hint',
                'puzzle-sequence',
                'puzzle-required-items',
                'puzzle-title',
                'puzzle-description',
                'puzzle-hints',
                'puzzle-secret-code',
                'slider-background-image',
                'slider-rows',
                'slider-cols'
            ];

            fieldsToClear.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) field.value = '';
            });

            // Limpar campos espec√≠ficos do egyptian puzzle
            for (let i = 1; i <= 4; i++) {
                const initialEl = document.getElementById(`piece${i}-initial`);
                const correctEl = document.getElementById(`piece${i}-correct`);
                if (initialEl) initialEl.value = '';
                if (correctEl) correctEl.value = '';
            }

            // Limpar shape match molds
            if (typeof currentMolds !== 'undefined') {
                currentMolds = [];
            }

            // Limpar √°rea de op√ß√µes de puzzle
            const puzzleOptionsDiv = document.getElementById('puzzle-options-container');
            if (puzzleOptionsDiv) {
                puzzleOptionsDiv.innerHTML = '';
            }
        }

        function loadPuzzleData(puzzle) {
            if (!puzzle) return;

            console.log('üì• Carregando dados do puzzle:', puzzle.id);
            console.log('   Type:', puzzle.type);

            document.getElementById('puzzle-id').value = puzzle.id || '';
            currentPuzzleType = puzzle.type;

            // Select puzzle type button
            document.querySelectorAll('.puzzle-type-btn').forEach(btn => btn.classList.remove('selected'));
            const typeBtn = Array.from(document.querySelectorAll('.puzzle-type-btn')).find(btn =>
                btn.textContent.includes(getPuzzleTypeName(puzzle.type))
            );
            if (typeBtn) typeBtn.classList.add('selected');

            renderPuzzleOptions(puzzle.type);

            // Fill in puzzle data
            setTimeout(() => {
                const questionEl = document.getElementById('puzzle-question');
                if (questionEl) questionEl.value = puzzle.question || '';

                if (puzzle.type === 'riddle') {
                    const optionsEl = document.getElementById('puzzle-options');
                    if (optionsEl && puzzle.options) {
                        optionsEl.value = puzzle.options.join('\n');
                    }
                    const answerEl = document.getElementById('puzzle-answer');
                    if (answerEl) answerEl.value = puzzle.correctAnswer || 0;
                    const hintEl = document.getElementById('puzzle-hint');
                    if (hintEl && puzzle.hint) hintEl.value = puzzle.hint;
                } else if (puzzle.type === 'sequence_symbols') {
                    const optionsEl = document.getElementById('puzzle-options');
                    if (optionsEl && puzzle.options) {
                        optionsEl.value = puzzle.options.join('\n');
                    }
                    const seqEl = document.getElementById('puzzle-sequence');
                    if (seqEl && puzzle.correctSequence) {
                        seqEl.value = puzzle.correctSequence.join(',');
                    }
                } else if (puzzle.type === 'math' || puzzle.type === 'code') {
                    const answerEl = document.getElementById('puzzle-answer');
                    if (answerEl) answerEl.value = puzzle.correctAnswer || '';
                    const hintEl = document.getElementById('puzzle-hint');
                    if (hintEl && puzzle.hint) hintEl.value = puzzle.hint;
                } else if (puzzle.type === 'item_combination' || puzzle.type === 'key_check') {
                    const itemsEl = document.getElementById('puzzle-required-items');
                    if (itemsEl && puzzle.requiredItems) {
                        itemsEl.value = puzzle.requiredItems.join(',');
                    }
                } else if (puzzle.type === 'egyptian') {
                    const titleEl = document.getElementById('puzzle-title');
                    if (titleEl && puzzle.title) titleEl.value = puzzle.title;

                    const descEl = document.getElementById('puzzle-description');
                    if (descEl && puzzle.description) descEl.value = puzzle.description;

                    const hintsEl = document.getElementById('puzzle-hints');
                    if (hintsEl && puzzle.hints) {
                        hintsEl.value = JSON.stringify(puzzle.hints, null, 2);
                    }

                    // Carregar rota√ß√µes das pe√ßas
                    if (puzzle.pieces && Array.isArray(puzzle.pieces)) {
                        puzzle.pieces.forEach((piece, index) => {
                            const pieceNum = index + 1;
                            const initialEl = document.getElementById(`piece${pieceNum}-initial`);
                            const correctEl = document.getElementById(`piece${pieceNum}-correct`);

                            if (initialEl && piece.initialRotation !== undefined) {
                                initialEl.value = piece.initialRotation;
                            }
                            if (correctEl && piece.correctRotation !== undefined) {
                                correctEl.value = piece.correctRotation;
                            }
                        });
                    }
                } else if (puzzle.type === 'padlock_5digit') {
                    const secretCodeEl = document.getElementById('puzzle-secret-code');
                    if (secretCodeEl && puzzle.secretCode) secretCodeEl.value = puzzle.secretCode;
                } else if (puzzle.type === 'shape_match') {
                    const titleEl = document.getElementById('puzzle-title');
                    if (titleEl && puzzle.title) titleEl.value = puzzle.title;

                    const descEl = document.getElementById('puzzle-description');
                    if (descEl && puzzle.description) descEl.value = puzzle.description;

                    const hintsEl = document.getElementById('puzzle-hints');
                    if (hintsEl && puzzle.hints) {
                        hintsEl.value = JSON.stringify(puzzle.hints, null, 2);
                    }

                    // Carregar moldes
                    if (puzzle.molds && Array.isArray(puzzle.molds)) {
                        currentMolds = puzzle.molds.map(m => ({ ...m }));
                        renderShapeMatchMolds();
                    }
                }

                // ‚úÖ Carregar unlock action para TODOS os tipos de puzzle
                const actionTypeEl = document.getElementById('puzzle-unlock-action-type');
                if (actionTypeEl && puzzle.onUnlockedAction) {
                    actionTypeEl.value = puzzle.onUnlockedAction.type || '';
                }

                const newBackgroundEl = document.getElementById('puzzle-new-background');
                if (newBackgroundEl && puzzle.onUnlockedAction?.newBackground) {
                    newBackgroundEl.value = puzzle.onUnlockedAction.newBackground;
                }

                const targetLocationEl = document.getElementById('puzzle-target-location');
                if (targetLocationEl && puzzle.onUnlockedAction?.targetLocation) {
                    targetLocationEl.value = puzzle.onUnlockedAction.targetLocation;
                }

                const unlockMessageEl = document.getElementById('puzzle-unlock-message');
                if (unlockMessageEl && puzzle.onUnlockedAction?.message) {
                    unlockMessageEl.value = puzzle.onUnlockedAction.message;
                }

                toggleUnlockActionFields();

                if (puzzle.reward) {
                    document.getElementById('puzzle-reward-id').value = puzzle.reward.id || '';
                    document.getElementById('puzzle-reward-name').value = puzzle.reward.name || '';
                    const rewardImageEl = document.getElementById('puzzle-reward-image');
                    if (rewardImageEl) rewardImageEl.value = puzzle.reward.image || '';
                }
            }, 100);
        }

        function getPuzzleTypeName(type) {
            const names = {
                riddle: 'Charada',
                sequence_symbols: 'Sequ√™ncia',
                math: 'Matem√°tica',
                code: 'C√≥digo',
                item_combination: 'Combinar Itens',
                padlock_5digit: 'Cadeado 5 D√≠gitos',
                egyptian: 'Parede Eg√≠pcia',
                shape_match: 'Conecta Blocos'
            };
            return names[type] || type;
        }

        // Toggle unlock action fields (para todos os tipos de puzzle)
        function toggleUnlockActionFields() {
            const actionType = document.getElementById('puzzle-unlock-action-type')?.value;
            const backgroundGroup = document.getElementById('unlock-new-background-group');
            const locationGroup = document.getElementById('unlock-target-location-group');
            const messageGroup = document.getElementById('unlock-message-group');

            if (!actionType || actionType === '') {
                // Nenhuma a√ß√£o
                if (backgroundGroup) backgroundGroup.style.display = 'none';
                if (locationGroup) locationGroup.style.display = 'none';
                if (messageGroup) messageGroup.style.display = 'none';
            } else if (actionType === 'changeBackground') {
                if (backgroundGroup) backgroundGroup.style.display = 'block';
                if (locationGroup) locationGroup.style.display = 'none';
                if (messageGroup) messageGroup.style.display = 'block';
            } else if (actionType === 'navigate') {
                if (backgroundGroup) backgroundGroup.style.display = 'none';
                if (locationGroup) locationGroup.style.display = 'block';
                if (messageGroup) messageGroup.style.display = 'none';
            }
        }

        // Shape Match Puzzle - Molds Management
        let currentMolds = [];

        function addShapeMatchMold() {
            const mold = {
                shape: 'circle',
                x: 50,  // ‚úÖ Porcentagem (centro horizontal)
                y: 50,  // ‚úÖ Porcentagem (centro vertical)
                item: '',
                label: ''
            };
            currentMolds.push(mold);
            renderShapeMatchMolds();
            savePuzzle();
        }

        function editShapeMatchMold(index) {
            const mold = currentMolds[index];

            const shape = prompt('Forma (circle, square, triangle, rectangle, star):', mold.shape);
            if (shape === null) return;

            const x = prompt('Posi√ß√£o X (0-100 = porcentagem, >100 = pixels):', mold.x);
            if (x === null) return;

            const y = prompt('Posi√ß√£o Y (0-100 = porcentagem, >100 = pixels):', mold.y);
            if (y === null) return;

            const item = prompt('ID do Item do invent√°rio:', mold.item);
            if (item === null) return;

            const label = prompt('Label (opcional):', mold.label);
            if (label === null) return;

            mold.shape = shape;

            // ‚úÖ Converter pixels para porcentagem se necess√°rio
            let xVal = parseFloat(x) || 50;
            let yVal = parseFloat(y) || 50;

            // Se usu√°rio digitou valor > 100, assumir que √© pixel e converter para %
            const visualCanvas = document.getElementById('visual-canvas');
            const containerWidth = visualCanvas?.offsetWidth || 800;
            const containerHeight = visualCanvas?.offsetHeight || 600;

            if (xVal > 100) {
                xVal = (xVal / containerWidth) * 100;
            }
            if (yVal > 100) {
                yVal = (yVal / containerHeight) * 100;
            }

            mold.x = xVal;
            mold.y = yVal;
            mold.item = item;
            mold.label = label;

            renderShapeMatchMolds();
            savePuzzle();
        }

        function deleteShapeMatchMold(index) {
            if (!confirm('Deletar este molde?')) return;
            currentMolds.splice(index, 1);
            renderShapeMatchMolds();
            savePuzzle();
        }

        function renderShapeMatchMolds() {
            const container = document.getElementById('molds-list');
            if (!container) return;

            if (currentMolds.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">Nenhum molde adicionado. Clique em "‚ûï Adicionar Molde"</p>';
                return;
            }

            container.innerHTML = currentMolds.map((mold, i) => `
                <div style="background: white; padding: 12px; margin-bottom: 10px; border-radius: 6px; border: 2px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong>Molde ${i + 1}</strong> -
                        Forma: <span style="color: #0066cc;">${mold.shape}</span> |
                        Posi√ß√£o: <span style="color: #666;">(${mold.x}, ${mold.y})</span> |
                        Item: <span style="color: #ff6600;">${mold.item || 'nenhum'}</span>
                        ${mold.label ? ` | Label: <span style="color: #009900;">${mold.label}</span>` : ''}
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button type="button" class="btn btn-sm" onclick="editShapeMatchMold(${i})" style="padding: 4px 10px;">‚úèÔ∏è Editar</button>
                        <button type="button" class="btn btn-sm btn-danger" onclick="deleteShapeMatchMold(${i})" style="padding: 4px 10px;">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('');
        }

        // ‚úÖ SALVAMENTO MANUAL - Salva TUDO no banco MySQL
        async function manualSave() {
            if (!currentLocationId) {
                showToast('‚ö†Ô∏è Selecione uma location primeiro', 'error');
                return;
            }

            // Salvar informa√ß√µes b√°sicas da location atual
            saveBasicInfo(false);  // false = n√£o triggera auto-save

            // Salvar puzzle se existir
            savePuzzle();

            // Fazer sync completo com MySQL
            autoSaveEnabled = true;  // Temporariamente habilitar para sync funcionar
            try {
                await syncToDatabase(false);  // false = mostrar toast
                showToast('‚úÖ TUDO SALVO NO BANCO!', 'success');
            } catch (error) {
                showToast('‚ùå Erro ao salvar: ' + error.message, 'error');
            } finally {
                autoSaveEnabled = false;  // Desabilitar novamente
            }
        }

        // Save puzzle
        function savePuzzle() {

            if (!currentLocationId) {
                return;
            }

            const hasPuzzle = document.getElementById('has-puzzle').checked;
            const location = gameLocations[currentLocationId];

            if (!hasPuzzle) {
                delete location.puzzle;
                if (autoSaveEnabled) {
                    autoSave();
                }
                showToast('‚úì Enigma removido!');
                if (selectedVisualType === 'puzzle') {
                    selectedVisualType = null;
                    selectedItemIndex = null;
                    renderTransformControls();
                    renderPositionedItems();
                    renderVisualItemsList();
                }
                return;
            }

            if (!currentPuzzleType) {
                showToast('Selecione um tipo de enigma!', 'warning');
                return;
            }

            // Gerar ID autom√°tico se estiver vazio
            let puzzleId = document.getElementById('puzzle-id').value.trim();
            if (!puzzleId) {
                puzzleId = currentLocationId + '_puzzle';
                document.getElementById('puzzle-id').value = puzzleId;
            }

            const puzzle = {
                id: puzzleId,
                type: currentPuzzleType
            };

            const questionEl = document.getElementById('puzzle-question');
            if (questionEl) puzzle.question = questionEl.value;

            if (currentPuzzleType === 'riddle') {
                const optionsEl = document.getElementById('puzzle-options');
                if (optionsEl) puzzle.options = optionsEl.value.split('\n').filter(o => o.trim());
                const answerEl = document.getElementById('puzzle-answer');
                if (answerEl) puzzle.correctAnswer = parseInt(answerEl.value);
                const hintEl = document.getElementById('puzzle-hint');
                if (hintEl && hintEl.value) puzzle.hint = hintEl.value;
            } else if (currentPuzzleType === 'sequence_symbols') {
                const optionsEl = document.getElementById('puzzle-options');
                if (optionsEl) puzzle.options = optionsEl.value.split('\n').filter(o => o.trim());
                const seqEl = document.getElementById('puzzle-sequence');
                if (seqEl) puzzle.correctSequence = seqEl.value.split(',').map(n => parseInt(n.trim()));
            } else if (currentPuzzleType === 'math' || currentPuzzleType === 'code') {
                const answerEl = document.getElementById('puzzle-answer');
                if (answerEl) puzzle.correctAnswer = parseInt(answerEl.value);
                const hintEl = document.getElementById('puzzle-hint');
                if (hintEl && hintEl.value) puzzle.hint = hintEl.value;
            } else if (currentPuzzleType === 'item_combination' || currentPuzzleType === 'key_check') {
                const itemsEl = document.getElementById('puzzle-required-items');
                if (itemsEl) puzzle.requiredItems = itemsEl.value.split(',').map(i => i.trim());
            } else if (currentPuzzleType === 'egyptian') {
                const titleEl = document.getElementById('puzzle-title');
                if (titleEl && titleEl.value) puzzle.title = titleEl.value;

                const descEl = document.getElementById('puzzle-description');
                if (descEl && descEl.value) puzzle.description = descEl.value;

                const hintsEl = document.getElementById('puzzle-hints');
                if (hintsEl && hintsEl.value) {
                    try {
                        puzzle.hints = JSON.parse(hintsEl.value);
                    } catch (e) {
                        console.warn('Hints inv√°lidos:', e);
                        puzzle.hints = [];
                    }
                }

                // Configura√ß√£o das pe√ßas (6 pe√ßas hexagonais)
                const symbols = ['ankh', 'eye', 'scarab', 'sun', 'bird', 'snake'];
                const positions = [
                    { x: -150, y: -80 }, // Pe√ßa 1 (topo esquerda)
                    { x: 0, y: -80 },    // Pe√ßa 2 (topo centro)
                    { x: 150, y: -80 },  // Pe√ßa 3 (topo direita)
                    { x: -150, y: 80 },  // Pe√ßa 4 (baixo esquerda)
                    { x: 0, y: 80 },     // Pe√ßa 5 (baixo centro)
                    { x: 150, y: 80 }    // Pe√ßa 6 (baixo direita)
                ];

                puzzle.pieces = [];
                for (let i = 1; i <= 6; i++) {
                    const initialEl = document.getElementById(`piece${i}-initial`);
                    const correctEl = document.getElementById(`piece${i}-correct`);

                    puzzle.pieces.push({
                        id: `piece${i}`,
                        symbol: symbols[i - 1],
                        initialRotation: initialEl ? parseInt(initialEl.value) : 0,
                        correctRotation: correctEl ? parseInt(correctEl.value) : 0,
                        position: positions[i - 1]
                    });
                }
            } else if (currentPuzzleType === 'padlock_5digit') {
                const secretCodeEl = document.getElementById('puzzle-secret-code');
                if (secretCodeEl) puzzle.secretCode = secretCodeEl.value;
            } else if (currentPuzzleType === 'shape_match') {
                const titleEl = document.getElementById('puzzle-title');
                if (titleEl && titleEl.value) puzzle.title = titleEl.value;

                const descEl = document.getElementById('puzzle-description');
                if (descEl && descEl.value) puzzle.description = descEl.value;

                const hintsEl = document.getElementById('puzzle-hints');
                if (hintsEl && hintsEl.value) {
                    try {
                        puzzle.hints = JSON.parse(hintsEl.value);
                    } catch (e) {
                        console.warn('Hints inv√°lidos:', e);
                        puzzle.hints = [];
                    }
                }

                // Salvar moldes
                puzzle.molds = currentMolds.map(m => ({ ...m }));
            }

            // ‚úÖ Salvar unlock action para TODOS os tipos de puzzle
            const actionTypeEl = document.getElementById('puzzle-unlock-action-type');
            const newBackgroundEl = document.getElementById('puzzle-new-background');
            const targetLocationEl = document.getElementById('puzzle-target-location');
            const unlockMessageEl = document.getElementById('puzzle-unlock-message');

            if (actionTypeEl && actionTypeEl.value) {
                puzzle.onUnlockedAction = {
                    type: actionTypeEl.value
                };

                if (puzzle.onUnlockedAction.type === 'changeBackground' && newBackgroundEl && newBackgroundEl.value) {
                    puzzle.onUnlockedAction.newBackground = newBackgroundEl.value;
                } else if (puzzle.onUnlockedAction.type === 'navigate' && targetLocationEl && targetLocationEl.value) {
                    puzzle.onUnlockedAction.targetLocation = targetLocationEl.value;
                }

                // Mensagem customizada (opcional)
                if (unlockMessageEl && unlockMessageEl.value) {
                    puzzle.onUnlockedAction.message = unlockMessageEl.value;
                }
            } else {
                // Se n√£o tem a√ß√£o selecionada, remover onUnlockedAction
                delete puzzle.onUnlockedAction;
            }

            const rewardId = document.getElementById('puzzle-reward-id').value;
            const rewardName = document.getElementById('puzzle-reward-name').value;
            const rewardImage = document.getElementById('puzzle-reward-image').value;
            if (rewardId && rewardName) {
                puzzle.reward = { id: rewardId, name: rewardName };
                if (rewardImage) {
                    puzzle.reward.image = rewardImage;
                }
            }

            // üõ°Ô∏è PROTE√á√ÉO: Garantir que estamos salvando APENAS na localiza√ß√£o atual
            if (!gameLocations[currentLocationId]) {
                console.error('‚ùå ERRO CR√çTICO: Location n√£o encontrada:', currentLocationId);
                showToast('Erro: localiza√ß√£o n√£o encontrada!', 'error');
                return;
            }

            // üîí PRESERVAR propriedades visuais existentes (n√£o v√™m do formul√°rio)
            const previousVisual = location.puzzle?.visual ? JSON.parse(JSON.stringify(location.puzzle.visual)) : null;
            const previousDigitPositions = location.puzzle?.digitPositions ? JSON.parse(JSON.stringify(location.puzzle.digitPositions)) : null;
            const previousDigitSize = location.puzzle?.digitSize ? JSON.parse(JSON.stringify(location.puzzle.digitSize)) : null;

            // Usar JSON para garantir deep copy (sem refer√™ncias)
            location.puzzle = JSON.parse(JSON.stringify(puzzle));

            // Restaurar propriedades visuais preservadas
            if (previousVisual) {
                location.puzzle.visual = previousVisual;
            } else {
                ensurePuzzleDefaults(location.puzzle);
            }

            // üîê Restaurar posi√ß√µes dos d√≠gitos do cadeado
            if (previousDigitPositions) {
                location.puzzle.digitPositions = previousDigitPositions;
            }
            if (previousDigitSize) {
                location.puzzle.digitSize = previousDigitSize;
            }

            console.log(`‚úÖ Puzzle salvo EXCLUSIVAMENTE para "${currentLocationId}":`, location.puzzle.id);

            // üîç VERIFICA√á√ÉO: Alertar se puzzle ID n√£o corresponde √† location
            const expectedPuzzleId = currentLocationId + '_puzzle';
            if (location.puzzle.id !== expectedPuzzleId && location.puzzle.id !== currentLocationId) {
                console.warn(`‚ö†Ô∏è AVISO: Puzzle ID "${location.puzzle.id}" n√£o segue o padr√£o esperado "${expectedPuzzleId}"`);
            }

            // ‚úÖ S√≥ sincroniza com banco se auto-save habilitado (clicou em Salvar)
            if (autoSaveEnabled) {
                autoSave();
            }
            showToast('‚úì Enigma salvo na mem√≥ria!');
            renderVisualItemsList();
            renderPositionedItems();
        }

        // Render items list
        function renderItemsList() {
            if (!currentLocationId) return;

            const location = gameLocations[currentLocationId];
            const list = document.getElementById('itemsList');

            if (!location.items || location.items.length === 0) {
                list.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üì¶</div><p>Nenhum item neste local</p></div>';
                return;
            }

            list.innerHTML = '';
            location.items.forEach((item, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'list-item';
                const decorativeBadge = item.isDecorative ? '<span style="background: #ff9800; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px;">üé® Decorativo</span>' : '';
                const displayBadge = item.isDisplayItem ? '<span style="background: #007bff; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px;">üìÑ Exibi√ß√£o</span>' : '';
                itemEl.innerHTML = `
                    <div class="list-item-content">
                        <div class="list-item-title">${item.name} ${decorativeBadge}${displayBadge}</div>
                        <div class="list-item-details">ID: ${item.id}${item.displayImage ? ` ‚Ä¢ Imagem: ${item.displayImage}` : ''}</div>
                    </div>
                    <div class="list-item-actions">
                        <button class="btn btn-secondary btn-small" onclick="editItem(${index})">‚úèÔ∏è Editar</button>
                        <button class="btn btn-danger btn-small" onclick="deleteItem(${index})">üóëÔ∏è</button>
                    </div>
                `;
                list.appendChild(itemEl);
            });
        }

        function addNewItem() {
            if (!currentLocationId) return;

            const itemId = prompt('ID do item (ex: old_coin):');
            if (!itemId) return;

            const itemName = prompt('Nome do item (ex: Moeda Antiga):');
            if (!itemName) return;

            const location = gameLocations[currentLocationId];
            if (!location.items) location.items = [];

            location.items.push({
                id: itemId,
                name: itemName,
                found: false,
                isDecorative: false  // ‚úÖ Default: item normal colet√°vel
            });
            autoSave();
            renderItemsList();
        }

        function editItem(index) {
            if (!currentLocationId) return;

            const location = gameLocations[currentLocationId];
            const item = location.items[index];

            const newId = prompt('ID do item:', item.id);
            if (newId === null) return;

            const newName = prompt('Nome do item:', item.name);
            if (newName === null) return;

            // Perguntar se √© item decorativo (mostrar status atual)
            const currentStatus = item.isDecorative ? 'SIM (j√° √© decorativo)' : 'N√ÉO (item normal colet√°vel)';
            const isDecorative = confirm(`Este item √© DECORATIVO (sem intera√ß√£o)?\n\n‚ö†Ô∏è STATUS ATUAL: ${currentStatus}\n\nItens decorativos:\n‚Ä¢ N√ÉO podem ser coletados\n‚Ä¢ N√ÉO aparecem no invent√°rio\n‚Ä¢ Servem apenas para anima√ß√£o/decora√ß√£o visual\n‚Ä¢ Suportam GIFs animados e spritesheets\n\nClique OK para DECORATIVO, Cancelar para NORMAL.`);

            let isDisplayItem = false;
            let displayImage = '';

            if (isDecorative) {
                // ‚úÖ DECORATIVO: pedir imagem do spritesheet/GIF (salva em displayImage)
                const currentImage = item.displayImage || item.image || '';
                displayImage = prompt('Imagem decorativa (PNG, GIF ou spritesheet):', currentImage);
            } else {
                // ITEM NORMAL: pedir imagem do invent√°rio
                const newImage = prompt('Imagem do item no invent√°rio:', item.image || '');
                if (newImage) item.image = newImage;

                // Perguntar se √© item de exibi√ß√£o
                isDisplayItem = confirm('Este item √© um ITEM DE EXIBI√á√ÉO (mapa, papel, foto)?\n\nQuando clicado no invent√°rio, abrir√° uma imagem em tela cheia para visualiza√ß√£o.\n\nClique OK para SIM, Cancelar para N√ÉO.');

                if (isDisplayItem) {
                    displayImage = prompt('Imagem de EXIBI√á√ÉO (imagem grande que aparece ao clicar no invent√°rio):', item.displayImage || '');
                }
            }

            // Atualizar item
            item.id = newId;
            item.name = newName;

            // Definir flags
            item.isDecorative = isDecorative;

            if (isDecorative) {
                // ‚úÖ PRESERVAR displayImage para itens decorativos
                if (displayImage) item.displayImage = displayImage;
                delete item.isDisplayItem;
            } else {
                item.isDisplayItem = isDisplayItem;
                if (isDisplayItem && displayImage) {
                    item.displayImage = displayImage;
                } else if (!isDisplayItem) {
                    delete item.displayImage;
                }
            }

            autoSave();
            renderItemsList();
        }

        function deleteItem(index) {
            if (!currentLocationId) return;

            if (!confirm('Remover este item?')) return;

            const location = gameLocations[currentLocationId];
            location.items.splice(index, 1);

            autoSave();
            renderItemsList();
        }

        // Render hotspots list
        function renderHotspotsList() {
            if (!currentLocationId) return;

            const location = gameLocations[currentLocationId];
            const list = document.getElementById('hotspotsList');

            if (!location.hotspots || location.hotspots.length === 0) {
                list.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üéØ</div><p>Nenhum hotspot neste local</p></div>';
                return;
            }

            list.innerHTML = '';
            location.hotspots.forEach((hotspot, index) => {
                const hotspotEl = document.createElement('div');
                hotspotEl.className = 'list-item';

                let arrowDirectionDropdown = '';
                if (hotspot.action === 'navigate') {
                    arrowDirectionDropdown = `
                        <div class="form-group" style="margin-top: 10px;">
                            <label style="font-size: 12px;">‚å®Ô∏è Dire√ß√£o da Seta (Teclado)</label>
                            <select onchange="updateHotspotArrowDirection(${index}, this.value)" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="" ${!hotspot.arrowDirection ? 'selected' : ''}>‚Äî Nenhuma ‚Äî</option>
                                <option value="up" ${hotspot.arrowDirection === 'up' ? 'selected' : ''}>‚¨ÜÔ∏è Cima</option>
                                <option value="down" ${hotspot.arrowDirection === 'down' ? 'selected' : ''}>‚¨áÔ∏è Baixo</option>
                                <option value="left" ${hotspot.arrowDirection === 'left' ? 'selected' : ''}>‚¨ÖÔ∏è Esquerda</option>
                                <option value="right" ${hotspot.arrowDirection === 'right' ? 'selected' : ''}>‚û°Ô∏è Direita</option>
                            </select>
                        </div>
                        <div class="form-group" style="margin-top: 10px;">
                            <label style="font-size: 12px;">üîç Tipo de Zoom</label>
                            <select onchange="updateHotspotZoomDirection(${index}, this.value)" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="" ${!hotspot.zoomDirection ? 'selected' : ''}>‚Äî Nenhum ‚Äî</option>
                                <option value="in" ${hotspot.zoomDirection === 'in' ? 'selected' : ''}>üîç+ In (aproximar)</option>
                                <option value="out" ${hotspot.zoomDirection === 'out' ? 'selected' : ''}>üîç- Out (afastar)</option>
                            </select>
                        </div>
                    `;
                }

                hotspotEl.innerHTML = `
                    <div class="list-item-content">
                        <div class="list-item-title">${hotspot.name}</div>
                        <div class="list-item-details">
                            ID: ${hotspot.id} | A√ß√£o: ${hotspot.action} | Posi√ß√£o: ${hotspot.position.x}%, ${hotspot.position.y}%
                        </div>
                        ${arrowDirectionDropdown}
                    </div>
                    <div class="list-item-actions">
                        <button class="btn btn-secondary btn-small" onclick="editHotspot(${index})">‚úèÔ∏è Editar</button>
                        <button class="btn btn-danger btn-small" onclick="deleteHotspot(${index})">üóëÔ∏è</button>
                    </div>
                `;
                list.appendChild(hotspotEl);
            });
        }

        function updateHotspotArrowDirection(index, direction) {
            if (!currentLocationId) return;
            const location = gameLocations[currentLocationId];
            const hotspot = location.hotspots[index];
            hotspot.arrowDirection = direction;
            autoSave();
        }

        function updateHotspotZoomDirection(index, zoomDirection) {
            if (!currentLocationId) return;
            const location = gameLocations[currentLocationId];
            const hotspot = location.hotspots[index];
            hotspot.zoomDirection = zoomDirection;
            autoSave();
            showToast(`Zoom: ${zoomDirection === 'in' ? 'In' : zoomDirection === 'out' ? 'Out' : 'Nenhum'}`);
        }

        function addNewHotspot() {
            if (!currentLocationId) return;

            const hotspotId = prompt('ID do hotspot (ex: fountain):');
            if (!hotspotId) return;

            const hotspotName = prompt('Nome do hotspot (ex: Fonte Seca):');
            if (!hotspotName) return;

            const action = prompt('A√ß√£o (examine, navigate, puzzle, collect):', 'examine');
            if (!action) return;

            const location = gameLocations[currentLocationId];
            if (!location.hotspots) location.hotspots = [];

            const newHotspot = {
                id: hotspotId,
                name: hotspotName,
                position: { x: 50, y: 50, width: 15, height: 15 },
                action: action
            };

            if (action === 'examine') {
                newHotspot.message = prompt('Mensagem ao examinar:', 'Algo interessante...');
            } else if (action === 'navigate') {
                newHotspot.target = prompt('ID do local de destino:');
            } else if (action === 'puzzle') {
                newHotspot.target = prompt('ID do puzzle:');
            } else if (action === 'collect') {
                newHotspot.itemId = prompt('ID do item a coletar:');
            }

            location.hotspots.push(newHotspot);
            autoSave();
            renderHotspotsList();
        }

        function editHotspot(index) {
            if (!currentLocationId) return;

            const location = gameLocations[currentLocationId];
            const hotspot = location.hotspots[index];

            const newName = prompt('Nome do hotspot:', hotspot.name);
            if (newName === null) return;
            hotspot.name = newName;

            const x = prompt('Posi√ß√£o X (%):', hotspot.position.x);
            if (x !== null) hotspot.position.x = parseInt(x);

            const y = prompt('Posi√ß√£o Y (%):', hotspot.position.y);
            if (y !== null) hotspot.position.y = parseInt(y);

            const width = prompt('Largura (%):', hotspot.position.width);
            if (width !== null) hotspot.position.width = parseInt(width);

            autoSave();
            renderHotspotsList();
            renderPositionedHotspots();
        }

        function deleteHotspot(index) {
            if (!currentLocationId) return;

            if (!confirm('Remover este hotspot?')) return;

            const location = gameLocations[currentLocationId];
            location.hotspots.splice(index, 1);

            autoSave();
            renderHotspotsList();
        }

        // Render connections list
        function renderConnectionsList() {
            if (!currentLocationId) return;

            const currentLocation = gameLocations[currentLocationId];
            const list = document.getElementById('connectionsList');
            list.innerHTML = '';

            Object.values(gameLocations).forEach(location => {
                if (location.id === currentLocationId) return;

                const isConnected = currentLocation.connections && currentLocation.connections.includes(location.id);

                const connEl = document.createElement('div');
                connEl.className = 'list-item';
                connEl.style.background = isConnected ? '#e8f5e9' : '#f9f9f9';
                connEl.innerHTML = `
                    <div class="list-item-content">
                        <div class="list-item-title">${location.name}</div>
                        <div class="list-item-details">ID: ${location.id}</div>
                    </div>
                    <div class="list-item-actions">
                        <button class="btn ${isConnected ? 'btn-danger' : 'btn-success'} btn-small"
                                onclick="toggleConnection('${location.id}')">
                            ${isConnected ? '‚úï Desconectar' : '+ Conectar'}
                        </button>
                    </div>
                `;
                list.appendChild(connEl);
            });
        }

        function toggleConnection(targetId) {
            if (!currentLocationId) return;

            const location = gameLocations[currentLocationId];
            const target = gameLocations[targetId];

            if (!location.connections) location.connections = [];
            if (!target.connections) target.connections = [];

            const index = location.connections.indexOf(targetId);
            if (index > -1) {
                // Remove connection (bidirectional)
                location.connections.splice(index, 1);
                const targetIndex = target.connections.indexOf(currentLocationId);
                if (targetIndex > -1) {
                    target.connections.splice(targetIndex, 1);
                }
            } else {
                // Add connection (bidirectional)
                location.connections.push(targetId);
                if (!target.connections.includes(currentLocationId)) {
                    target.connections.push(currentLocationId);
                }
            }

            autoSave();
            renderConnectionsList();
        }

        // Add new location
        function addNewLocation() {
            const locationId = prompt('ID do novo local (ex: new_area):');
            if (!locationId || !locationId.trim()) return;

            if (gameLocations[locationId]) {
                showToast('J√° existe um local com este ID!', 'error');
                return;
            }

            const locationName = prompt('Nome do novo local (ex: √Årea Nova):');
            if (!locationName) return;

            gameLocations[locationId] = {
                id: locationId,
                name: locationName,
                description: 'Descri√ß√£o do local...',
                image: `images/${locationId}.jpg`,
                unlocked: false,
                connections: [],
                hotspots: [],
                items: []
            };

            // Add to location order at the end
            locationOrder.push(locationId);

            autoSave();
            renderLocationsList();
            selectLocation(locationId);
        }

        // Delete location
        async function deleteLocation(locationId) {
            if (!confirm(`Tem certeza que deseja remover o local "${gameLocations[locationId].name}"?`)) return;

            showToast('üóëÔ∏è Removendo localiza√ß√£o...', 'info');

            try {
                // Delete from MySQL first
                const response = await fetch(`api/locations/delete.php?id=${locationId}`, {
                    method: 'DELETE'
                });
                const result = await response.json();

                if (!result.success) {
                    showToast('‚ùå Erro ao deletar do banco: ' + result.message, 'error');
                    return;
                }

                // Remove connections in other locations
                Object.values(gameLocations).forEach(loc => {
                    if (loc.connections) {
                        loc.connections = loc.connections.filter(conn => conn !== locationId);
                    }
                    if (loc.hotspots) {
                        loc.hotspots = loc.hotspots.filter(hotspot => hotspot.target !== locationId);
                    }
                });

                delete gameLocations[locationId];

                // Remove from location order
                const orderIndex = locationOrder.indexOf(locationId);
                if (orderIndex > -1) {
                    locationOrder.splice(orderIndex, 1);
                }

                if (currentLocationId === locationId) {
                    currentLocationId = null;
                    document.getElementById('currentLocationName').textContent = 'Selecione um local';
                    document.getElementById('currentLocationId').textContent = '';
                }

                autoSave();
                renderLocationsList();
                showToast('‚úÖ Localiza√ß√£o removida com sucesso!', 'success');

            } catch (error) {
                console.error('Erro ao deletar:', error);
                showToast('‚ùå Erro ao deletar localiza√ß√£o', 'error');
            }
        }

        // Export game data
        function exportGameData() {
            const code = `// Vila Abandonada - Game Map Data
// Generated by Location Editor

const GAME_MAP = ${JSON.stringify(gameLocations, null, 4)};

// Helper functions
function getLocation(locationId) {
    return GAME_MAP[locationId];
}

function getUnlockedLocations() {
    return Object.values(GAME_MAP).filter(loc => loc.unlocked);
}

// Export for use in game
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { GAME_MAP, getLocation, getUnlockedLocations };
}`;

            document.getElementById('exportedCode').textContent = code;
            document.getElementById('exportModal').classList.add('active');
        }

        // IndexedDB helpers (suporta arquivos grandes)
        function openGameDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('VilaAbandonadaDB', 1);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('gameData')) {
                        db.createObjectStore('gameData');
                    }
                };
            });
        }

        async function saveToIndexedDB(key, data) {
            const db = await openGameDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['gameData'], 'readwrite');
                const store = transaction.objectStore('gameData');
                const request = store.put(data, key);

                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async function loadFromIndexedDB(key) {
            const db = await openGameDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['gameData'], 'readonly');
                const store = transaction.objectStore('gameData');
                const request = store.get(key);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function deleteFromIndexedDB(key) {
            const db = await openGameDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['gameData'], 'readwrite');
                const store = transaction.objectStore('gameData');
                const request = store.delete(key);

                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Save to game via IndexedDB (suporta arquivos grandes)
        async function saveToGame() {
            try {
                await saveToIndexedDB('gameLocations', gameLocations);
                showToast('‚úÖ Salvo no jogo!');
            } catch (e) {
                showToast('‚ùå Erro ao salvar: ' + e.message, 'error');
            }
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.remove('active');
        }

        function copyExportedCode() {
            const code = document.getElementById('exportedCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                showToast('‚úì C√≥digo copiado!');
            });
        }

        // Hotspot Navigation Modal Functions
        let hotspotNavResolve = null;
        let hotspotNavReject = null;

        function showHotspotNavModal(initialName = '', initialTarget = '') {
            return new Promise((resolve, reject) => {
                hotspotNavResolve = resolve;
                hotspotNavReject = reject;

                // Set title based on mode (edit vs add)
                const isEditMode = initialName !== '' || initialTarget !== '';
                document.getElementById('hotspotNavModalTitle').textContent =
                    isEditMode ? 'Editar Hotspot de Navega√ß√£o' : 'Adicionar Hotspot de Navega√ß√£o';

                // Populate location select
                const select = document.getElementById('hotspotNavTarget');
                select.innerHTML = '<option value="">-- Selecione uma localiza√ß√£o --</option>';

                // Ordenar localiza√ß√µes alfabeticamente por ID
                const sortedLocations = Object.keys(gameLocations)
                    .map(id => ({ id, name: gameLocations[id].name }))
                    .sort((a, b) => a.id.localeCompare(b.id));

                for (const loc of sortedLocations) {
                    const option = document.createElement('option');
                    option.value = loc.id;
                    option.textContent = loc.id;
                    select.appendChild(option);
                }

                // Set initial values
                document.getElementById('hotspotNavName').value = initialName;
                document.getElementById('hotspotNavTarget').value = initialTarget;

                // Show modal
                document.getElementById('hotspotNavModal').style.display = 'flex';
                document.getElementById('hotspotNavName').focus();
            });
        }

        function confirmHotspotNav() {
            const name = document.getElementById('hotspotNavName').value.trim();
            const target = document.getElementById('hotspotNavTarget').value;

            if (!name) {
                showToast('‚ùå Nome do hotspot √© obrigat√≥rio', 'error');
                return;
            }

            if (!target) {
                showToast('‚ùå Local de destino √© obrigat√≥rio', 'error');
                return;
            }

            document.getElementById('hotspotNavModal').style.display = 'none';
            if (hotspotNavResolve) {
                hotspotNavResolve({ name, target });
                hotspotNavResolve = null;
                hotspotNavReject = null;
            }
        }

        function cancelHotspotNav() {
            document.getElementById('hotspotNavModal').style.display = 'none';
            if (hotspotNavReject) {
                hotspotNavReject(new Error('Cancelled'));
                hotspotNavResolve = null;
                hotspotNavReject = null;
            }
        }

        function resetEditorData() {
            if (confirm('Tem certeza que deseja resetar todos os dados do editor? Isso ir√° apagar todas as suas altera√ß√µes e restaurar os dados para o padr√£o do arquivo.')) {
                openGameDB().then(db => {
                    const transaction = db.transaction(['gameData'], 'readwrite');
                    const store = transaction.objectStore('gameData');
                    store.delete('editorData');
                    store.delete('gameLocations');
                    transaction.oncomplete = () => {
                        showToast('Dados resetados! Recarregando...');
                        setTimeout(() => location.reload(), 1000);
                    };
                }).catch(err => {
                    showToast('Erro ao resetar: ' + err.message, 'error');
                });
            }
        }

        // ============================================
        // DATABASE SYNC FUNCTIONS
        // ============================================

        async function forceReloadFromDatabase() {
            if (!confirm('üîÑ Recarregar TODOS os dados do banco?\n\nIsso vai SUBSTITUIR qualquer mudan√ßa local n√£o salva.')) {
                return;
            }

            showToast('üóëÔ∏è Limpando cache local...', 'info');

            // Limpar IndexedDB
            try {
                await deleteFromIndexedDB('editorData');
            } catch (e) {
                console.warn('Erro ao limpar IndexedDB:', e);
            }

            // Recarregar do banco
            await loadFromDatabase(false);

            showToast('‚úÖ Dados recarregados do banco!', 'success');
        }

        async function loadFromDatabase(auto = false) {
            // ‚ö†Ô∏è IMPORTANTE: Sync mudan√ßas n√£o sincronizadas antes de carregar!
            const hasUnsyncedChanges = localStorage.getItem('unsyncedChanges') === 'true';

            if (hasUnsyncedChanges) {
                await loadFromLocalStorage();
                await syncToDatabase(true);
            }

            if (!auto) {
                showToast('üîÑ Carregando do banco...', 'info');
            } else {
            }

            try {
                const response = await fetch('api/locations/list.php');
                const result = await response.json();

                if (!result.success) {
                    showToast('‚ùå Erro: ' + result.message, 'error');
                    return;
                }

                const locations = result.data.locations;

                if (locations.length === 0) {
                    if (!auto) {
                        showToast('‚ö†Ô∏è Banco est√° vazio. Execute migrate-ui.html primeiro!', 'error');
                        return;
                    } else {
                        console.warn('Banco vazio, usando dados locais');
                        await loadFromLocalStorage();
                        return;
                    }
                }

                // Convert API format to editor format

                gameLocations = {};
                locationOrder = [];

                locations.forEach(loc => {
                    // Separar hotspots entre navega√ß√£o e items
                    const hotspots = [];
                    const items = [];

                    (loc.hotspots || []).forEach(h => {
                        if (h.type === 'item' && h.item_id) {
                            // Este √© um item, n√£o um hotspot de navega√ß√£o
                            items.push({
                                id: h.item_id,
                                name: h.label || h.item_id,
                                description: h.description || '',
                                image: h.item_image || '',  // ‚úÖ Incluir imagem do JOIN
                                isDisplayItem: h.is_display_item === 1 || h.is_display_item === '1' || h.is_display_item === true,
                                isDecorative: h.is_decorative === 1 || h.is_decorative === '1' || h.is_decorative === true,  // ‚úÖ Carregar flag decorativo do banco
                                displayImage: h.display_image || null,
                                position: {
                                    x: parseFloat(h.x) || 50,
                                    y: parseFloat(h.y) || 50
                                },
                                size: {
                                    width: parseFloat(h.width) || 5,
                                    height: parseFloat(h.height) || 5
                                },
                                transform: {
                                    rotation: parseFloat(h.rotation) || 0,
                                    rotateX: parseFloat(h.rotate_x) || 0,
                                    rotateY: parseFloat(h.rotate_y) || 0,
                                    scaleX: parseFloat(h.scale_x) || 1,
                                    scaleY: parseFloat(h.scale_y) || 1,
                                    skewX: parseFloat(h.skew_x) || 0,
                                    skewY: parseFloat(h.skew_y) || 0,
                                    flipX: h.flip_x === 1 || h.flip_x === '1' || h.flip_x === true,
                                    flipY: h.flip_y === 1 || h.flip_y === '1' || h.flip_y === true,
                                    opacity: parseFloat(h.opacity) ?? 1,
                                    shadowBlur: parseFloat(h.shadow_blur) || 0,
                                    shadowOffsetX: parseFloat(h.shadow_offset_x) || 0,
                                    shadowOffsetY: parseFloat(h.shadow_offset_y) || 0
                                },
                                found: false
                            });
                        } else {
                            // Este √© um hotspot de navega√ß√£o/intera√ß√£o
                            let action = h.type || 'navigate';
                            if (action === 'navigation') action = 'navigate';

                            const hotspotData = {
                                id: 'hotspot_' + Date.now() + Math.random(),
                                name: h.label || 'Hotspot',
                                action: action,
                                target: h.target_location || '',
                                position: {
                                    x: parseFloat(h.x) || 0,
                                    y: parseFloat(h.y) || 0,
                                    width: parseFloat(h.width) || 10,
                                    height: parseFloat(h.height) || 10
                                },
                                item: h.item_id || null
                            };

                            // ‚úÖ Carregar corners do banco (quadril√°tero irregular)
                            if (h.corners) {
                                try {
                                    hotspotData.corners = typeof h.corners === 'string'
                                        ? JSON.parse(h.corners)
                                        : h.corners;
                                } catch (e) {
                                    console.error('Erro ao parsear corners:', e);
                                }
                            }

                            // ‚úÖ Preservar arrow_direction e zoom_direction do banco
                            if (h.arrow_direction) {
                                hotspotData.arrowDirection = h.arrow_direction;
                            }
                            if (h.zoom_direction) {
                                hotspotData.zoomDirection = h.zoom_direction;
                            }

                            hotspots.push(hotspotData);
                        }
                    });

                    gameLocations[loc.id] = {
                        id: loc.id,
                        name: loc.name,
                        description: loc.description,
                        image: loc.background_image,
                        unlocked: true,
                        connections: [],
                        hotspots: hotspots,
                        items: items,
                        imageDimensions: { width: 1024, height: 1024 },
                        destructibleWalls: loc.destructible_walls || [],  // ‚úÖ Carregar paredes do banco
                        isFinalScene: loc.is_final_scene || false,  // ‚úÖ Carregar flag de cena final
                        credits: loc.credits || null,  // ‚úÖ Carregar cr√©ditos
                        transitionVideo: loc.transition_video || null  // ‚úÖ Carregar v√≠deo de transi√ß√£o
                    };

                    if (loc.puzzle) {
                        gameLocations[loc.id].puzzle = loc.puzzle;
                        ensurePuzzleDefaults(gameLocations[loc.id].puzzle);
                    } else {
                    }

                    locationOrder.push(loc.id);
                });

                // ‚úÖ Construir array de connections a partir dos hotspots de navega√ß√£o
                for (const locationId in gameLocations) {
                    const location = gameLocations[locationId];
                    location.connections = []; // Limpar primeiro

                    // Para cada hotspot de navega√ß√£o, adicionar √† lista de connections
                    (location.hotspots || []).forEach(h => {
                        if (h.action === 'navigate' && h.target && h.target.trim() !== '') {
                            // Adicionar conex√£o se ainda n√£o existe
                            if (!location.connections.includes(h.target)) {
                                location.connections.push(h.target);
                            }
                        }
                    });
                }

                // Salvar no IndexedDB SOMENTE se N√ÉO houver mudan√ßas pendentes
                // Isso mant√©m IndexedDB sincronizado com MySQL, mas n√£o sobrescreve mudan√ßas recentes
                if (!hasUnsyncedChanges) {
                    await saveToIndexedDB('editorData', {
                        locations: gameLocations,
                        order: locationOrder
                    });
                }

                renderLocationsList();

                if (!auto) {
                    showToast(`‚úÖ ${locations.length} localiza√ß√µes carregadas do banco!`);
                } else {
                }

            } catch (error) {
                console.error('Load error:', error);
                if (!auto) {
                    showToast('‚ùå Erro ao carregar: ' + error.message, 'error');
                }
                // Se auto e falhar, tenta carregar do IndexedDB
                if (auto) {
                    console.warn('Banco vazio ou erro, usando dados locais');
                    await loadFromLocalStorage();
                }
            }
        }

        async function syncToDatabase(silent = false) {
            if (!autoSaveEnabled) return; // ‚úÖ N√£o salvar automaticamente

            // IMPORTANTE: Salvar informa√ß√µes b√°sicas da localiza√ß√£o atual ANTES de sincronizar
            if (currentLocationId) {
                saveBasicInfo(false); // false = n√£o disparar autoSave novamente (evita loop infinito)
            }

            if (Object.keys(gameLocations).length === 0) {
                if (!silent) {
                    alert('‚ùå Nenhuma localiza√ß√£o para salvar! gameLocations est√° vazio.');
                }
                console.error('‚ùå gameLocations est√° vazio!');
                return;
            }

            if (!silent) {
                showToast('‚òÅÔ∏è Sincronizando TODAS as localiza√ß√µes de uma vez...', 'info');
            }

            const startTime = Date.now();

            try {
                // Converter TODAS as localiza√ß√µes de uma vez
                const allLocations = [];

                for (const locationId in gameLocations) {
                    const loc = gameLocations[locationId];

                    // Convert editor format to API format
                    const navigationHotspots = (loc.hotspots || []).map(h => ({
                        type: h.action === 'navigate' ? 'navigation' : h.action === 'item' ? 'item' : 'interaction',
                        x: h.position?.x || 0,
                        y: h.position?.y || 0,
                        width: h.position?.width || 10,
                        height: h.position?.height || 10,
                        corners: h.corners ? JSON.stringify(h.corners) : null,
                        label: h.name || '',
                        description: h.description || '',
                        target_location: h.target || null,
                        item_id: h.item || null,
                        arrow_direction: h.arrowDirection || null,
                        zoom_direction: h.zoomDirection || null
                    }));

                    // IMPORTANTE: Converter items para hotspots do tipo 'item'
                    const itemHotspots = (loc.items || []).map(item => {
                        const hotspot = {
                            type: 'item',
                            item_id: item.id,
                            label: item.name,
                            description: item.description,
                            item_image: item.image,
                            is_display_item: item.isDisplayItem ? 1 : 0,
                            is_decorative: item.isDecorative ? 1 : 0,
                            // ‚úÖ Para decorativos, usar item.image como display_image (spritesheets/GIFs)
                            display_image: item.isDecorative ? item.image : (item.displayImage || null),
                        x: item.position.x,
                        y: item.position.y,
                        width: item.size.width,
                        height: item.size.height,
                        rotation: item.transform?.rotation || 0,
                        rotate_x: item.transform?.rotateX || 0,
                        rotate_y: item.transform?.rotateY || 0,
                        scale_x: item.transform?.scaleX || 1,
                        scale_y: item.transform?.scaleY || 1,
                        skew_x: item.transform?.skewX || 0,
                        skew_y: item.transform?.skewY || 0,
                        flip_x: item.transform?.flipX ? 1 : 0,
                        flip_y: item.transform?.flipY ? 1 : 0,
                        opacity: item.transform?.opacity || 1,
                        shadow_blur: item.transform?.shadowBlur || 0,
                        shadow_offset_x: item.transform?.shadowOffsetX || 0,
                        shadow_offset_y: item.transform?.shadowOffsetY || 0
                        };

                        return hotspot;
                    });

                    // Combinar hotspots de navega√ß√£o + items
                    const allHotspots = [...navigationHotspots, ...itemHotspots];

                    allLocations.push({
                        id: locationId,
                        name: loc.name,
                        description: loc.description,
                        background_image: loc.background || loc.image,
                        hotspots: allHotspots,
                        puzzle: loc.puzzle,
                        destructible_walls: loc.destructibleWalls || [],
                        is_final_scene: loc.isFinalScene || false,
                        credits: loc.credits || null,
                        transition_video: loc.transitionVideo || null,
                        dramatic_messages: loc.dramaticMessages || null,
                        dramatic_message_duration: loc.dramaticMessageDuration || null
                    });
                }

                const response = await fetch('api/locations/bulk-save.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        locations: allLocations,
                        order: locationOrder
                    })
                });

                if (!response.ok) {
                        const text = await response.text();
                        console.error(`‚ùå HTTP ${response.status}:`, text);
                        if (!silent) {
                            showToast('‚ùå Erro ao salvar: ' + text.substring(0, 100), 'error');
                        }
                        return;
                    }

                    const result = await response.json();

                    const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);

                    if (result.success) {
                        // Limpar flag de mudan√ßas n√£o sincronizadas
                        localStorage.removeItem('unsyncedChanges');

                        // ‚úÖ CR√çTICO: Salvar tamb√©m no IndexedDB para persistir ao dar F5
                        await saveToIndexedDB('editorData', {
                            locations: gameLocations,
                            order: locationOrder
                        });

                        if (!silent) {
                            showToast(`‚úÖ ${result.data.locations} localiza√ß√µes e ${result.data.hotspots} hotspots salvos em ${elapsed}s!`, 'success');
                        }
                    } else {
                        console.error(`‚ùå Erro:`, result.message);
                        if (!silent) {
                            showToast(`‚ùå Erro: ${result.message}`, 'error');
                        }
                    }

                } catch (error) {
                    console.error('‚ùå Erro ao sincronizar:', error);
                    if (!silent) {
                        showToast('‚ùå Erro ao sincronizar: ' + error.message, 'error');
                    }
                }
            }

        // Ajustar escala quando janela redimensiona
        let editorResizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(editorResizeTimeout);
                editorResizeTimeout = setTimeout(() => {
                    adjustEditorContainer();
                    renderPositionedHotspots();
                }, 100);
            });
    </script>
</body>

</html>